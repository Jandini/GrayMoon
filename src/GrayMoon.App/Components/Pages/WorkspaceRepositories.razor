@page "/workspaces/{WorkspaceId:int}"
@rendermode @(new InteractiveServerRenderMode(prerender: false))
@implements IDisposable
@using GrayMoon.App.Models
@using GrayMoon.App.Repositories
@using GrayMoon.App.Services
@using GrayMoon.App.Components.Shared
@using GrayMoon.App.Components.Modals
@using Microsoft.AspNetCore.SignalR.Client
@inject WorkspaceRepository WorkspaceRepository
@inject WorkspaceGitService WorkspaceGitService
@inject IServiceScopeFactory ServiceScopeFactory
@inject ConnectorRepository ConnectorRepository
@inject GitHubRepositoryService RepositoryService
@inject NavigationManager NavigationManager
@inject ILogger<WorkspaceRepositories> Logger
@using WorkspaceModel = GrayMoon.App.Models.Workspace

<PageTitle>@(workspace?.Name ?? "Workspace")</PageTitle>

<div class="container-fluid page-container grid-page">
    <div class="grid-page-header">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <div>
                <h2>@(workspace?.Name ?? "Workspace")</h2>
                <p class="text-muted mb-0" style="min-height: 1.5rem;">
                    @if (workspaceRepositories.Count > 0)
                    {
                        <span class="repositories-count-link" @onclick="ShowRepositoriesModalAsync" @onclick:preventDefault>
                            @($"{workspaceRepositories.Count} {(workspaceRepositories.Count == 1 ? "repository" : "repositories")}")
                        </span>
                    }
                    else if (workspace != null)
                    {
                        <span class="repositories-count-link" @onclick="ShowRepositoriesModalAsync" @onclick:preventDefault>0 repositories</span>
                    }
                    else
                    {
                        <span>&nbsp;</span>
                    }
                </p>
            </div>
            <div class="d-flex gap-2">
                <button class="btn @(hasUnmatchedDependencies ? "btn-danger" : "btn-secondary")"
                        @onclick="UpdateDependenciesAsync"
                        disabled="@(workspace == null || workspaceRepositories.Count == 0 || isSyncing || isUpdating)">
                    Update
                </button>
                <button class="btn @(isOutOfSync == true ? "btn-danger" : "btn-primary")"
                        @onclick="SyncAsync"
                        disabled="@(isSyncing || isUpdating || workspaceRepositories.Count == 0)">
                    Sync
                </button>
            </div>
        </div>
        @if (errorMessage != null)
        {
            <div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i> @errorMessage
            </div>
        }
    </div>
    @if (errorMessage == null)
    {
        <div class="grid-page-body">
            <div class="card page-card mb-4">
                <div class="card-body p-0">
                    <div class="table-responsive">
                        <table class="table table-striped table-hover mb-0 repositories-table resizable-columns">
                        <thead class="table-dark">
                            <tr>
                                <th class="col-repo">Repository</th>
                                <th class="col-version">Version</th>
                                <th class="col-branch">Branch</th>
                                <th class="col-deps">Dependencies</th>
                                <th class="col-commits">Commits</th>
                                <th class="col-sync col-status-badge">Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            @if (isLoading)
                            {
                                <tr>
                                    <td colspan="6" class="text-center text-muted py-4">
                                        Loading workspace...
                                    </td>
                                </tr>
                            }
                            else if (workspaceRepositories.Count == 0)
                            {
                                <tr>
                                    <td colspan="6" class="text-center text-muted py-4">
                                        No repositories assigned to this workspace.
                                    </td>
                                </tr>
                            }
                            else
                            {
                                @foreach (var wr in workspaceRepositories)
                                {
                                    var repo = wr.Repository;
                                    @if (repo != null)
                                    {
                                        var repoUrl = GetRepositoryUrl(repo);
                                        var branchUrl = !string.IsNullOrEmpty(repoUrl) && !string.IsNullOrEmpty(wr.BranchName)
                                            ? $"{repoUrl}/compare/main...{Uri.EscapeDataString(wr.BranchName)}"
                                            : null;
                                        <tr>
                                            <td class="col-repo">
                                                @if (!string.IsNullOrEmpty(repoUrl))
                                                {
                                                    <a href="@repoUrl" target="_blank" rel="noopener noreferrer" class="repo-link">
                                                        <strong>@repo.RepositoryName</strong>
                                                    </a>
                                                }
                                                else
                                                {
                                                    <strong>@repo.RepositoryName</strong>
                                                }
                                            </td>
                                            <td class="col-version text-muted">@(wr.GitVersion ?? "-")</td>
                                            <td class="col-branch">
                                                @if (!string.IsNullOrEmpty(branchUrl))
                                                {
                                                    <a href="@branchUrl" target="_blank" rel="noopener noreferrer" class="branch-link">@(wr.BranchName ?? "-")</a>
                                                }
                                                else
                                                {
                                                    <span class="branch-text">@(wr.BranchName ?? "-")</span>
                                                }
                                            </td>
                                            <td class="col-deps col-status-badge">
                                                @{
                                                    var depCount = wr.Dependencies ?? 0;
                                                    var unmatchedDeps = wr.UnmatchedDeps ?? 0;
                                                }
                                                @if (depCount == 0)
                                                {
                                                    <span class="badge build-dep-badge build-dep-badge-none">0</span>
                                                }
                                                else if (unmatchedDeps == 0)
                                                {
                                                    <span class="badge build-dep-badge build-dep-badge-ok">@depCount</span>
                                                }
                                                else
                                                {
                                                    <span class="badge build-dep-badge build-dep-badge-mismatch">@unmatchedDeps of @depCount</span>
                                                }
                                            </td>
                                            <td class="col-commits">@GetCommitsBadge(wr.OutgoingCommits, wr.IncomingCommits)</td>
                                            <td class="col-sync col-status-badge">@GetRepoSyncBadge(repo.RepositoryId)</td>
                                        </tr>
                                    }
                                }
                            }
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        </div>
    }
</div>

<WorkspaceRepositoriesModal IsVisible="@showRepositoriesModal"
                            Title="@($"Repositories for {workspace?.Name ?? "Workspace"}")"
                            Repositories="@repositoriesModalRepositories"
                            SelectedRepositoryIds="@selectedRepositoryIds"
                            HasConnectors="@hasConnectors"
                            IsSaving="@isSavingRepositories"
                            IsFetching="@isPersisting"
                            ErrorMessage="@repositoriesModalErrorMessage"
                            OnSave="@SaveRepositoriesAsync"
                            OnCancel="@CloseRepositoriesModal"
                            OnFetchRepositories="@FetchRepositoriesAsync" />

<LoadingOverlay IsVisible="@isLoading" Message="Loading workspace..." />
<LoadingOverlay IsVisible="@isSyncing" Message="@syncProgressMessage" OnAbort="AbortSyncAsync" />
<LoadingOverlay IsVisible="@isUpdating" Message="@updateProgressMessage" OnAbort="AbortUpdateAsync" />
<LoadingOverlay IsVisible="@(showRepositoriesModal && isPersisting)" Message="@(fetchedRepositoryCount is null || fetchedRepositoryCount == 0 ? "Fetching repositories..." : $"Fetched {fetchedRepositoryCount} {(fetchedRepositoryCount == 1 ? "repository" : "repositories")}...")" OnAbort="AbortFetchRepositories" />

@code {
    [Parameter] public int WorkspaceId { get; set; }

    private WorkspaceModel? workspace;
    private List<WorkspaceRepositoryLink> workspaceRepositories = new();
    private IReadOnlyDictionary<int, RepoGitVersionInfo> repoGitInfos = new Dictionary<int, RepoGitVersionInfo>();
    private string? errorMessage;
    private bool isLoading = true;
    private bool isSyncing = false;
    private string syncProgressMessage = "Synchronizing...";
    private bool isUpdating = false;
    private string updateProgressMessage = "Updating dependencies...";
    private CancellationTokenSource? _updateCts;
    private bool? isOutOfSync = null;
    private bool hasUnmatchedDependencies => workspaceRepositories.Any(wr => (wr.UnmatchedDeps ?? 0) > 0);
    private Dictionary<int, RepoSyncStatus> repoSyncStatus = new();
    private CancellationTokenSource? _syncCts;
    private HubConnection? _hubConnection;
    private bool showRepositoriesModal;
    private bool isSavingRepositories;
    private bool isPersisting;
    private bool hasConnectors;
    private string? repositoriesModalErrorMessage;
    private List<GitHubRepositoryEntry>? repositoriesModalRepositories;
    private HashSet<int> selectedRepositoryIds = new();
    private int? fetchedRepositoryCount;
    private CancellationTokenSource? _fetchRepositoriesCts;

    protected override async Task OnInitializedAsync()
    {
        await LoadWorkspaceAsync();
        ApplySyncStateFromWorkspace();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && workspace != null && errorMessage == null)
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/hubs/workspace-sync"))
                .WithAutomaticReconnect()
                .Build();
            _hubConnection.On<int>("WorkspaceSynced", async (workspaceId) =>
            {
                if (workspaceId == WorkspaceId)
                    await InvokeAsync(RefreshFromSync);
            });
            await _hubConnection.StartAsync();
        }
    }

    private void ApplySyncStateFromWorkspace()
    {
        if (workspace == null || workspaceRepositories.Count == 0)
        {
            return;
        }
        repoSyncStatus = workspaceRepositories
            .Where(wr => wr.Repository != null)
            .ToDictionary(wr => wr.RepositoryId, wr => wr.SyncStatus);
        isOutOfSync = repoSyncStatus.Values.Any(s => s != RepoSyncStatus.InSync);
        StateHasChanged();
    }

    public void Dispose()
    {
        _ = _hubConnection?.StopAsync();
        _hubConnection?.DisposeAsync();
        _syncCts?.Cancel();
        _syncCts?.Dispose();
        _updateCts?.Cancel();
        _updateCts?.Dispose();
        _fetchRepositoriesCts?.Cancel();
        _fetchRepositoriesCts?.Dispose();
    }

    /// <summary>Called when WorkspaceSynced is received (or after Update): reload from a fresh scope so the grid gets current DB values (no stale DbContext).</summary>
    private async Task RefreshFromSync()
    {
        if (isSyncing || isUpdating)
            return;
        await ReloadWorkspaceDataFromFreshScopeAsync();
        ApplySyncStateFromWorkspace();
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadWorkspaceAsync()
    {
        try
        {
            isLoading = true;
            errorMessage = null;
            await ReloadWorkspaceDataAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading workspace {WorkspaceId}", WorkspaceId);
            errorMessage = "Failed to load workspace. Please try again later.";
            workspaceRepositories = new List<WorkspaceRepositoryLink>();
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task ReloadWorkspaceDataAsync()
    {
        workspace = await WorkspaceRepository.GetByIdAsync(WorkspaceId);
        if (workspace == null)
        {
            errorMessage = "Workspace not found.";
            workspaceRepositories = new List<WorkspaceRepositoryLink>();
            return;
        }

        workspaceRepositories = workspace.Repositories
            .OrderByDescending(wr => wr.Sequence ?? int.MinValue)
            .ThenByDescending(wr => wr.Dependencies ?? int.MinValue)
            .ToList();
    }

    /// <summary>Loads workspace using a new scope (fresh DbContext) so we get current DB values and avoid EF cache. Used by RefreshFromSync so the grid shows updated UnmatchedDeps after notify or Update.</summary>
    private async Task ReloadWorkspaceDataFromFreshScopeAsync()
    {
        await using var scope = ServiceScopeFactory.CreateAsyncScope();
        var repo = scope.ServiceProvider.GetRequiredService<WorkspaceRepository>();
        var w = await repo.GetByIdAsync(WorkspaceId);
        if (w == null)
        {
            errorMessage = "Workspace not found.";
            workspaceRepositories = new List<WorkspaceRepositoryLink>();
            return;
        }
        workspace = w;
        workspaceRepositories = workspace.Repositories
            .OrderByDescending(wr => wr.Sequence ?? int.MinValue)
            .ThenByDescending(wr => wr.Dependencies ?? int.MinValue)
            .ToList();
    }

    private RenderFragment GetCommitsBadge(int? outgoing, int? incoming) => builder =>
    {
        var x = outgoing ?? 0;
        var y = incoming ?? 0;
        if (!outgoing.HasValue && !incoming.HasValue)
        {
            builder.AddContent(0, "-");
            return;
        }
        var text = $"↑{x} ↓{y}";
        string bgColor;
        if (y > 0)
            bgColor = "#dc3545";   // red: need to pull
        else if (x > 0)
            bgColor = "#fd7e14";   // orange: need to push
        else
            bgColor = "#198754";   // green: in sync (0,0)
        builder.OpenElement(0, "span");
        builder.AddAttribute(1, "class", "badge");
        builder.AddAttribute(2, "style", $"background-color: {bgColor}; color: #fff;");
        builder.AddContent(3, text);
        builder.CloseElement();
    };

    private RenderFragment GetRepoSyncBadge(int repositoryId) => builder =>
    {
        if (repoSyncStatus.TryGetValue(repositoryId, out var status))
        {
            var (text, bgColor) = status switch
            {
                RepoSyncStatus.InSync => ("in sync", "#198754"),
                RepoSyncStatus.NeedsSync => ("sync", "#dc3545"),
                RepoSyncStatus.NotCloned => ("not cloned", "#6c757d"),
                RepoSyncStatus.VersionMismatch => ("version", "#dc3545"),
                RepoSyncStatus.Error => ("error", "#dc3545"),
                _ => ("sync", "#6c757d")
            };
            builder.OpenElement(0, "span");
            builder.AddAttribute(1, "class", "badge");
            builder.AddAttribute(2, "style", $"background-color: {bgColor}; color: #fff;");
            builder.AddContent(3, text);
            builder.CloseElement();
        }
    };

    private void AbortSyncAsync()
    {
        _syncCts?.Cancel();
    }

    private void AbortUpdateAsync()
    {
        _updateCts?.Cancel();
    }

    /// <summary>User-triggered: refresh project/dependency data and write .csproj files to match referenced versions. Runs in a fresh scope so the DB context sees current state (e.g. UnmatchedDeps from notify) and GetSyncDependenciesPayloadAsync returns correct payload.</summary>
    private async Task UpdateDependenciesAsync()
    {
        if (workspace == null || workspaceRepositories.Count == 0 || isUpdating || isSyncing)
            return;

        _updateCts?.Cancel();
        _updateCts?.Dispose();
        _updateCts = new CancellationTokenSource();

        isUpdating = true;
        updateProgressMessage = "Refreshing projects...";
        errorMessage = null;
        try
        {
            StateHasChanged();
            await Task.Yield();

            await using (var scope = ServiceScopeFactory.CreateAsyncScope())
            {
                var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
                await workspaceGitService.RefreshWorkspaceProjectsAsync(
                    WorkspaceId,
                    onProgress: (completed, total, _) =>
                    {
                        updateProgressMessage = $"Refreshing projects {completed} of {total}";
                        InvokeAsync(StateHasChanged);
                    },
                    cancellationToken: _updateCts.Token);

                updateProgressMessage = "Syncing dependencies...";
                await InvokeAsync(StateHasChanged);
                await workspaceGitService.SyncDependenciesAsync(
                    WorkspaceId,
                    onProgress: (completed, total, _) =>
                    {
                        updateProgressMessage = $"Synced dependencies {completed} of {total}";
                        InvokeAsync(StateHasChanged);
                    },
                    cancellationToken: _updateCts.Token);

                await workspaceGitService.RecomputeAndBroadcastWorkspaceSyncedAsync(WorkspaceId, _updateCts.Token);
            }

            isUpdating = false;
            await InvokeAsync(StateHasChanged);
            await RefreshFromSync();
        }
        catch (OperationCanceledException)
        {
            isUpdating = false;
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating dependencies for workspace {WorkspaceId}", WorkspaceId);
            errorMessage = "Update failed. The GrayMoon Agent may be offline. Start the Agent and try again.";
        }
        finally
        {
            isUpdating = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ShowRepositoriesModalAsync()
    {
        if (workspace == null)
        {
            return;
        }
        repositoriesModalErrorMessage = null;
        selectedRepositoryIds = workspace.Repositories
            .Select(link => link.RepositoryId)
            .ToHashSet();
        await EnsureRepositoriesForModalAsync();
        showRepositoriesModal = true;
    }

    private async Task EnsureRepositoriesForModalAsync()
    {
        var connectors = await ConnectorRepository.GetAllAsync();
        hasConnectors = connectors.Count > 0;
        if (repositoriesModalRepositories == null && hasConnectors)
        {
            repositoriesModalRepositories = await RepositoryService.GetPersistedRepositoriesAsync();
        }
    }

    private void CloseRepositoriesModal()
    {
        showRepositoriesModal = false;
        repositoriesModalErrorMessage = null;
    }

    private async Task SaveRepositoriesAsync()
    {
        if (workspace == null || isSavingRepositories)
        {
            return;
        }
        if (selectedRepositoryIds.Count == 0)
        {
            repositoriesModalErrorMessage = "Select at least one repository.";
            return;
        }
        isSavingRepositories = true;
        repositoriesModalErrorMessage = null;
        await InvokeAsync(StateHasChanged);
        try
        {
            await WorkspaceRepository.UpdateAsync(WorkspaceId, workspace.Name, selectedRepositoryIds);
            CloseRepositoriesModal();
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving repositories for workspace {WorkspaceId}", WorkspaceId);
            repositoriesModalErrorMessage = ex.Message;
        }
        finally
        {
            isSavingRepositories = false;
        }
    }

    private void AbortFetchRepositories()
    {
        _fetchRepositoriesCts?.Cancel();
    }

    private async Task FetchRepositoriesAsync()
    {
        if (!hasConnectors || isPersisting)
        {
            return;
        }
        _fetchRepositoriesCts?.Cancel();
        _fetchRepositoriesCts = new CancellationTokenSource();
        try
        {
            isPersisting = true;
            fetchedRepositoryCount = null;
            repositoriesModalErrorMessage = null;
            await InvokeAsync(StateHasChanged);
            var progress = new Progress<int>(count =>
            {
                fetchedRepositoryCount = count;
                _ = InvokeAsync(StateHasChanged);
            });
            var result = await RepositoryService.RefreshRepositoriesAsync(progress, _fetchRepositoriesCts.Token);
            repositoriesModalRepositories = result.Repositories.ToList();
        }
        catch (OperationCanceledException)
        {
            repositoriesModalRepositories = await RepositoryService.GetPersistedRepositoriesAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error fetching repositories");
            repositoriesModalErrorMessage = "Failed to fetch repositories. Please try again later.";
            repositoriesModalRepositories = new List<GitHubRepositoryEntry>();
        }
        finally
        {
            isPersisting = false;
        }
    }

    /// <summary>Sync repos only (git, version, branch, commit counts). Does not read or write .csproj; dependency mismatches are resolved only by Update. Runs in a fresh scope so DbContext is not stale and PersistVersionsAsync → dependency recompute sees current state.</summary>
    private async Task SyncAsync()
    {
        if (workspace == null || workspaceRepositories.Count == 0 || isSyncing)
        {
            return;
        }

        _syncCts?.Cancel();
        _syncCts = new CancellationTokenSource();

        isSyncing = true;
        syncProgressMessage = "Synchronizing...";
        errorMessage = null;
        try
        {
            StateHasChanged();
            await Task.Yield();

            await using (var scope = ServiceScopeFactory.CreateAsyncScope())
            {
                var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
                var results = await workspaceGitService.SyncAsync(
                    WorkspaceId,
                    onProgress: (completed, total, repoId, info) =>
                    {
                        syncProgressMessage = $"Synchronized {completed} of {total}";
                        repoSyncStatus[repoId] = (info.Version == "-" && info.Branch == "-")
                            ? RepoSyncStatus.Error
                            : RepoSyncStatus.InSync;
                        var wr = workspaceRepositories.FirstOrDefault(w => w.RepositoryId == repoId);
                        if (wr != null)
                        {
                            wr.GitVersion = info.Version == "-" ? null : info.Version;
                            wr.BranchName = info.Branch == "-" ? null : info.Branch;
                            wr.Projects = info.Projects;
                            wr.OutgoingCommits = info.OutgoingCommits;
                            wr.IncomingCommits = info.IncomingCommits;
                        }
                        InvokeAsync(StateHasChanged);
                    },
                    cancellationToken: _syncCts.Token);
                repoGitInfos = results;
            }
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
            isOutOfSync = repoSyncStatus.Values.Any(v => v != RepoSyncStatus.InSync);
        }
        catch (OperationCanceledException)
        {
            // Sync was cancelled - reload workspace to restore pre-sync data (onProgress may have partially updated in-memory state)
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error syncing workspace {WorkspaceId}", WorkspaceId);
            errorMessage = "Sync failed. The GrayMoon Agent may be offline. Start the Agent and try again.";
        }
        finally
        {
            isSyncing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private string? GetRepositoryUrl(Repository repo)
    {
        if (string.IsNullOrEmpty(repo.CloneUrl))
            return null;

        // Convert git clone URL to GitHub web URL
        // Examples:
        // https://github.com/org/repo.git -> https://github.com/org/repo
        // git@github.com:org/repo.git -> https://github.com/org/repo
        // https://github.com/org/repo -> https://github.com/org/repo (already correct)
        
        var url = repo.CloneUrl.Trim();
        
        // Handle SSH format: git@github.com:org/repo.git
        if (url.StartsWith("git@github.com:", StringComparison.OrdinalIgnoreCase))
        {
            url = url.Replace("git@github.com:", "https://github.com/", StringComparison.OrdinalIgnoreCase);
        }
        // Handle HTTPS format: https://github.com/org/repo.git
        else if (url.StartsWith("https://github.com/", StringComparison.OrdinalIgnoreCase) || 
                 url.StartsWith("http://github.com/", StringComparison.OrdinalIgnoreCase))
        {
            // Already HTTPS/HTTP, just need to remove .git if present
        }
        else
        {
            // Unknown format, return null
            return null;
        }
        
        // Remove .git suffix if present
        if (url.EndsWith(".git", StringComparison.OrdinalIgnoreCase))
        {
            url = url.Substring(0, url.Length - 4);
        }
        
        return url;
    }
}
