@page "/workspaces/{WorkspaceId:int}"
@rendermode @(new InteractiveServerRenderMode(prerender: false))
@implements IDisposable
@using GrayMoon.App.Models
@using GrayMoon.App.Models.Api
@using GrayMoon.App.Repositories
@using GrayMoon.App.Services
@using GrayMoon.App.Components.Shared
@using GrayMoon.App.Components.Modals
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.SignalR.Client
@using System.Text.Json
@inject WorkspaceRepository WorkspaceRepository
@inject WorkspaceGitService WorkspaceGitService
@inject IServiceScopeFactory ServiceScopeFactory
@inject ConnectorRepository ConnectorRepository
@inject GitHubRepositoryService RepositoryService
@inject NavigationManager NavigationManager
@inject ILogger<WorkspaceRepositories> Logger
@inject IHttpClientFactory HttpClientFactory
@inject IJSRuntime JSRuntime
@inject IToastService ToastService
@inject WorkspaceFileVersionService FileVersionService
@using WorkspaceModel = GrayMoon.App.Models.Workspace

<PageTitle>@(workspace?.Name ?? "Workspace")</PageTitle>

<div class="container-fluid page-container grid-page">
    <div class="grid-page-header">
        <div class="workspace-repos-header">
            <div class="workspace-repos-title-row">
                <h2 class="workspace-repos-title">@(workspace?.Name ?? "Workspace")</h2>
                <p class="text-muted mb-0 workspace-repos-subtitle">
                    <NavLink href="workspaces" class="workspaces-breadcrumb-link" style="color: var(--text-muted) !important;">workspace</NavLink><span> | </span>
                    @if (workspaceRepositories.Count > 0)
                    {
                        var hasFilter = !string.IsNullOrWhiteSpace(searchTerm);
                        var list = hasFilter ? FilteredWorkspaceRepositories : workspaceRepositories;
                        var count = list.Count;
                        var selectedInList = showSelectionColumn && gridSelectedRepositoryIds.Count > 0
                            ? list.Count(wr => gridSelectedRepositoryIds.Contains(wr.RepositoryId))
                            : 0;
                        var suffix = hasFilter ? " found" : "";
                        <span class="repositories-count-link" @onclick="ShowRepositoriesModalAsync" @onclick:preventDefault>
                            @(selectedInList > 0
                                ? $"selected {selectedInList} of {count} {(count == 1 ? "repository" : "repositories")}{suffix}"
                                : $"{count} {(count == 1 ? "repository" : "repositories")}{suffix}")
                        </span>
                    }
                    else if (workspace != null)
                    {
                        <span class="repositories-count-link" @onclick="ShowRepositoriesModalAsync" @onclick:preventDefault>0 repositories</span>
                    }
                    else
                    {
                        <span>&nbsp;</span>
                    }
                </p>
            </div>
            <div class="d-flex gap-2 align-items-center workspace-repos-header-actions">
                <div class="workspace-repos-search-wrapper">
                    <div role="button"
                         tabindex="0"
                         class="btn workspace-repos-select-btn"
                         @onclick="ToggleSelectionModeAsync"
                         @onkeydown="OnSelectionModeKeyDown"
                         title="@(showSelectionColumn ? "Run commands against all repositories (selection kept)" : "Show checkboxes to run Push, Update, Branch, Sync only on selected repos")">
                        <input type="checkbox"
                               class="form-check-input workspace-repos-mode-checkbox @(showSelectionColumn && gridSelectedRepositoryIds.Count > 0 ? "" : "workspace-repos-mode-checkbox--all")"
                               checked="@(showSelectionColumn && gridSelectedRepositoryIds.Count > 0)"
                               readonly
                               tabindex="-1"
                               aria-hidden="true" />
                    </div>
                    <input id="workspace-repos-search" class="form-control workspace-repos-search" placeholder="Search repositories..."
                           @bind="searchTerm" @bind:event="oninput"
                           @onkeydown="OnSearchKeyDown" />
                </div>
                <button class="btn btn-outline-secondary"
                        @onclick="ShowBranchModalAsync"
                        disabled="@(isSyncing || isUpdating || isPushing || workspaceRepositories.Count == 0)">
                    Branch
                </button>
                <button class="btn @(hasUnmatchedDependencies ? "btn-danger" : "btn-outline-secondary")"
                        @onclick="OnUpdateClickAsync"
                        disabled="@(workspace == null || workspaceRepositories.Count == 0 || isSyncing || isUpdating || isPushing)">
                    Update
                </button>
                <button class="btn @(isPushRecommended ? "btn-warning" : "btn-outline-secondary")"
                        @onclick="OnPushClickAsync"
                        disabled="@(workspace == null || workspaceRepositories.Count == 0 || isSyncing || isUpdating || isPushing)">
                    Push
                </button>
                <button class="btn @(isOutOfSync == true ? "btn-danger" : "btn-primary")"
                        @onclick="SyncAsync"
                        disabled="@(isSyncing || isUpdating || isPushing || workspaceRepositories.Count == 0)">
                    Sync
                </button>
            </div>
        </div>
        @if (errorMessage != null)
        {
            <div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i> @errorMessage
            </div>
        }
    </div>
    @if (errorMessage == null)
    {
        <div class="grid-page-body">
            @if (_selectionStateLoaded)
            {
                <div class="card page-card mb-4">
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover mb-0 repositories-table resizable-columns">
                        <thead class="table-dark">
                            <tr>
                                @if (showSelectionColumn)
                                {
                                    <th class="col-select no-resize">
                                        <input type="checkbox"
                                               class="form-check-input workspace-repo-checkbox"
                                               checked="@(FilteredWorkspaceRepositories.Count > 0 && FilteredWorkspaceRepositories.All(wr => gridSelectedRepositoryIds.Contains(wr.RepositoryId)))"
                                               @onchange="ToggleSelectAllFilteredAsync"
                                               title="Select all filtered repositories" />
                                    </th>
                                }
                                <th class="col-repo">Repository</th>
                                <th class="col-version">Version</th>
                                <th class="col-branch">Branch</th>
                                <th class="col-deps">Dependencies</th>
                                <th class="col-commits">Commits</th>
                                <th class="col-sync col-status-badge">Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            @{
                                var colSpan = showSelectionColumn ? 7 : 6;
                            }
                            @if (isLoading)
                            {
                                <tr>
                                    <td colspan="@colSpan" class="text-center text-muted py-4">
                                        Loading workspace...
                                    </td>
                                </tr>
                            }
                            else if (workspaceRepositories.Count == 0)
                            {
                                <tr>
                                    <td colspan="@colSpan" class="text-center text-muted py-4">
                                        No repositories assigned to this workspace.
                                    </td>
                                </tr>
                            }
                            else if (FilteredWorkspaceRepositories.Count == 0)
                            {
                                <tr>
                                    <td colspan="@colSpan" class="text-center text-muted py-4">
                                        No repositories match your search.
                                    </td>
                                </tr>
                            }
                            else
                            {
                                @foreach (var group in FilteredLevelGroups)
                                {
                                    var levelUrls = group.Select(wr => wr.Repository).Where(r => r != null).Select(r => GetRepositoryUrl(r!)).Where(u => !string.IsNullOrEmpty(u)).ToList();
                                    var levelUrlsJson = System.Text.Json.JsonSerializer.Serialize(levelUrls);
                                    var levelPrUrls = new List<string>();
                                    foreach (var wr in group)
                                    {
                                        if (wr.Repository == null || string.IsNullOrWhiteSpace(wr.BranchName)) continue;
                                        var repoUrl = GetRepositoryUrl(wr.Repository);
                                        if (string.IsNullOrEmpty(repoUrl)) continue;
                                        levelPrUrls.Add($"{repoUrl}/compare/main...{Uri.EscapeDataString(wr.BranchName)}");
                                    }
                                    var levelPrUrlsJson = System.Text.Json.JsonSerializer.Serialize(levelPrUrls);
                                    <tr class="dependency-level-header">
                                        <td colspan="@colSpan" class="dependency-level-header-cell">
                                            <span class="dependency-level-title @(group.Key == null ? "dependency-level-no-projects" : "")">@(group.Key == null ? "No dependencies" : $"Level {group.Key}")</span>
                                            <span class="dependency-level-links">
                                                <span class="dependency-level-icons">
                                                    @if (group.Key.HasValue)
                                                    {
                                                        <a href="@GetDependencyGraphUrlForLevel(group.Key!.Value)" class="dependency-level-graph-link" title="View dependency graph for this level" aria-label="Dependency graph">
                                                            <i class="bi bi-diagram-3" aria-hidden="true"></i>
                                                        </a>
                                                    }
                                                    <span class="dependency-level-pr-link"
                                                          role="button"
                                                          tabindex="0"
                                                          title="Open Pull Request (current branch to main)..."
                                                          style="cursor: pointer;"
                                                          @onclick="() => ShowConfirmOpenPr(group.Count(), levelPrUrls)"
                                                          @onclick:preventDefault
                                                          @onclick:stopPropagation
                                                          aria-label="Open Pull Request">
                                                        <i class="bi bi-git" aria-hidden="true"></i>
                                                    </span>
                                                    <span class="dependency-level-sync-commits-link"
                                                          role="button"
                                                          tabindex="0"
                                                          title="Sync commits for all repositories in this level..."
                                                          style="cursor: pointer;"
                                                          @onclick="() => ShowConfirmSyncCommitsLevel(group.Select(wr => wr.RepositoryId).ToList())"
                                                          @onclick:preventDefault
                                                          aria-label="Sync commits">
                                                        <i class="bi bi-arrow-repeat" aria-hidden="true"></i>
                                                    </span>
                                                </span>
                                                <span class="dependency-level-count dependency-level-count-link"
                                                      role="button"
                                                      tabindex="0"
                                                      title="Open in GitHub..."
                                                      style="cursor: pointer;"
                                                      @onclick="() => ShowConfirmOpenGitHub(group.Count(), levelUrls)"
                                                      @onclick:preventDefault
                                                      @onclick:stopPropagation>
                                                    <span class="dependency-level-count-num">@group.Count()</span> @(group.Count() == 1 ? "repository" : "repositories")
                                                </span>
                                            </span>
                                        </td>
                                    </tr>
                                    @foreach (var wr in group)
                                    {
                                        var repo = wr.Repository;
                                        @if (repo != null)
                                        {
                                            var repoUrl = GetRepositoryUrl(repo);
                                            var branchUrl = !string.IsNullOrEmpty(repoUrl) && !string.IsNullOrEmpty(wr.BranchName)
                                                ? $"{repoUrl}/compare/main...{Uri.EscapeDataString(wr.BranchName)}"
                                                : null;
                                            <tr>
                                            @if (showSelectionColumn)
                                            {
                                                <td class="col-select">
                                                    <input type="checkbox"
                                                           class="form-check-input workspace-repo-checkbox"
                                                           checked="@gridSelectedRepositoryIds.Contains(wr.RepositoryId)"
                                                           @onchange="() => ToggleRepositorySelection(wr.RepositoryId)"
                                                           @onclick:stopPropagation="true" />
                                                </td>
                                            }
                                            <td class="col-repo">
                                                @if (!string.IsNullOrEmpty(repoUrl))
                                                {
                                                    <a href="@repoUrl" target="_blank" rel="noopener noreferrer" class="repo-link">
                                                        @if (showSelectionColumn) { <span>@repo.RepositoryName</span> } else { <strong>@repo.RepositoryName</strong> }
                                                    </a>
                                                }
                                                else
                                                {
                                                    @if (showSelectionColumn) { <span>@repo.RepositoryName</span> } else { <strong>@repo.RepositoryName</strong> }
                                                }
                                            </td>
                                            <td class="col-version">
                                                @if (!string.IsNullOrEmpty(wr.GitVersion))
                                                {
                                                    <div class="version-container @(clickedVersions.Contains(wr.GitVersion) ? "version-clicked" : "")"
                                                         @onmouseleave='() => OnVersionMouseLeave(wr.GitVersion)'>
                                                        <span class="version-inner text-muted"
                                                              @onclick='() => CopyVersionToClipboard(wr.GitVersion)'
                                                              title="Click to copy version">@wr.GitVersion</span>
                                                    </div>
                                                }
                                                else
                                                {
                                                    <span class="text-muted">-</span>
                                                }
                                            </td>
                                            <td class="col-branch">
                                                @if (!string.IsNullOrEmpty(wr.BranchName))
                                                {
                                                    <div class="branch-container">
                                                        <span class="branch-inner"
                                                              @onclick='() => ShowSwitchBranchModal(repo.RepositoryId, wr.BranchName, repo.CloneUrl)'
                                                              title="Click to switch branch">@wr.BranchName</span>
                                                    </div>
                                                }
                                                else
                                                {
                                                    <span>-</span>
                                                }
                                            </td>
                                            <td class="col-deps col-status-badge">
                                                @{
                                                    var depCount = wr.Dependencies ?? 0;
                                                    var unmatchedDeps = wr.UnmatchedDeps ?? 0;
                                                    var graphUrl = GetDependencyGraphUrl(repo.RepositoryId);
                                                }
                                                @if (depCount == 0)
                                                {
                                                    <a href="@graphUrl" class="dependency-badge-link" title="View dependency graph for this repository">
                                                        <span class="badge build-dep-badge build-dep-badge-none">0</span>
                                                    </a>
                                                }
                                                else if (unmatchedDeps == 0)
                                                {
                                                    <a href="@graphUrl" class="dependency-badge-link" title="View dependency graph for this repository">
                                                        <span class="badge build-dep-badge build-dep-badge-ok">@depCount</span>
                                                    </a>
                                                }
                                                else
                                                {
                                                    <span class="dependency-badge-link @(isUpdating || isSyncing ? "dependency-badge-link--disabled" : "")"
                                                          role="button"
                                                          tabindex="0"
                                                          title="@(unmatchedDeps) of @(depCount) dependencies require update. Click to update this repository only."
                                                          style="cursor: pointer;"
                                                          @onclick="() => ShowConfirmUpdateDependenciesAsync(repo.RepositoryId, unmatchedDeps)"
                                                          @onclick:preventDefault
                                                          @onkeydown="(e) => HandleDependencyBadgeKeydown(e, repo.RepositoryId, unmatchedDeps)">
                                                        <span class="badge build-dep-badge build-dep-badge-mismatch">@unmatchedDeps of @depCount</span>
                                                    </span>
                                                }
                                            </td>
                                            <td class="col-commits">@GetCommitsBadge(repo.RepositoryId, wr.OutgoingCommits, wr.IncomingCommits, wr.BranchHasUpstream, wr.BranchName)</td>
                                            <td class="col-sync col-status-badge">@GetRepoSyncBadge(repo.RepositoryId)</td>
                                        </tr>
                                            @if (repositoryErrors.TryGetValue(repo.RepositoryId, out var repoError))
                                            {
                                                <tr class="repo-error-row">
                                                    <td colspan="@colSpan" class="p-0">
                                                        <div class="alert alert-danger alert-dismissible mb-0 rounded-0" 
                                                             role="alert"
                                                             style="@(isSyncing ? "" : "cursor: pointer;")"
                                                             @onclick="async () => { if (!isSyncing) await SyncSingleRepoAsync(repo.RepositoryId); }"
                                                             title="@(isSyncing ? "" : "Click to sync this repository")">
                                                            <div class="d-flex align-items-start">
                                                                <div class="flex-grow-1" style="white-space: pre-wrap; word-wrap: break-word;">
                                                                    <strong>Error:</strong> @repoError
                                                                </div>
                                                                <button type="button" 
                                                                        class="btn-close ms-2" 
                                                                        aria-label="Close"
                                                                        @onclick:stopPropagation="true"
                                                                        @onclick='() => DismissRepositoryError(repo.RepositoryId)'></button>
                                                            </div>
                                                        </div>
                                                    </td>
                                                </tr>
                                            }
                                        }
                                    }
                                }
                            }
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
            }
            else
            {
                <div class="card page-card mb-4">
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover mb-0 repositories-table">
                                <tbody>
                                    <tr>
                                        <td colspan="6" class="text-center text-muted py-4">Loading...</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            }
        </div>
    }
</div>

<WorkspaceRepositoriesModal IsVisible="@showRepositoriesModal"
                            Title="@($"Repositories for {workspace?.Name ?? "Workspace"}")"
                            Repositories="@repositoriesModalRepositories"
                            SelectedRepositoryIds="@selectedRepositoryIds"
                            HasConnectors="@hasConnectors"
                            IsSaving="@isSavingRepositories"
                            IsFetching="@isPersisting"
                            ErrorMessage="@repositoriesModalErrorMessage"
                            OnSave="@SaveRepositoriesAsync"
                            OnCancel="@CloseRepositoriesModal"
                            OnFetchRepositories="@FetchRepositoriesAsync" />

<BranchModal IsVisible="@showBranchModal"
                   WorkspaceName="@(workspace?.Name)"
                   WorkspaceId="@WorkspaceId"
                   CommonBranchNames="@branchModalCommonBranches"
                   DefaultDisplayText="@branchModalDefaultDisplayText"
                   OnCancel="@CloseBranchModal"
                   OnCreateBranch="@CreateBranchesAsync" />

<SwitchBranchModal IsVisible="@showSwitchBranchModal"
                   WorkspaceId="@WorkspaceId"
                   RepositoryId="@switchBranchRepositoryId"
                   RepositoryName="@switchBranchRepositoryName"
                   CurrentBranch="@switchBranchCurrentBranch"
                   RepositoryUrl="@switchBranchRepositoryUrl"
                   OnCancel="@CloseSwitchBranchModal"
                   OnBranchChanged="@OnBranchChangedAsync"
                   OnCheckoutBranch="@CheckoutBranchAsync"
                   OnSyncToDefault="@SyncToDefaultFromModalAsync"
                   OnCreateBranch="@CreateSingleBranchAsync" />

<UpdateDependenciesModal IsVisible="@showUpdateModal"
                          IsMultiLevel="@updatePlanIsMultiLevel"
                          IsBusy="@isUpdating"
                          OnProceed="@OnUpdateProceedAsync"
                          OnUpdateOnly="@OnUpdateOnlyAsync"
                          OnCancel="@CloseUpdateModal" />

<UpdateSingleRepositoryDependenciesModal IsVisible="@showUpdateSingleRepoDependenciesModal"
                          Payload="@updateSingleRepoDependenciesPayload"
                          RepoName="@updateSingleRepoDependenciesRepoName"
                          OnProceed="@OnUpdateSingleRepositoryDependenciesProceedAsync"
                          OnCancel="@CloseUpdateSingleRepositoryDependenciesModal" />

<PushWithDependenciesModal IsVisible="@showPushWithDependenciesModal"
          Info="@pushWithDependenciesInfo"
          RepoName="@pushWithDependenciesRepoName"
          OnProceed="@OnPushWithDependenciesProceedAsync"
          OnCancel="@ClosePushWithDependenciesModal" />

<ConfirmModal IsVisible="@showConfirmModal"
              Message="@confirmModalMessage"
              ConfirmButtonText="Yes"
              OnConfirm="@OnConfirmModalYesAsync"
              OnCancel="@CloseConfirmModal" />

<LoadingOverlay IsVisible="@isLoading" Message="Loading workspace..." />
<LoadingOverlay IsVisible="@isSyncing" Message="@syncProgressMessage" OnAbort="AbortSyncAsync" />
<LoadingOverlay IsVisible="@isPushing" Message="@pushProgressMessage" OnAbort="AbortPushAsync" />
<LoadingOverlay IsVisible="@isUpdating" Message="@updateProgressMessage" OnAbort="AbortUpdateAsync" />
<LoadingOverlay IsVisible="@isCommitSyncing" Message="@commitSyncProgressMessage" OnAbort="AbortCommitSyncAsync" />
<LoadingOverlay IsVisible="@isCheckingOut" Message="@checkoutProgressMessage" OnAbort="AbortCheckoutAsync" />
<LoadingOverlay IsVisible="@(showRepositoriesModal && isPersisting)" Message="@(fetchedRepositoryCount is null || fetchedRepositoryCount == 0 ? "Fetching repositories..." : $"Fetched {fetchedRepositoryCount} {(fetchedRepositoryCount == 1 ? "repository" : "repositories")}")" OnAbort="AbortFetchRepositories" />
<LoadingOverlay IsVisible="@isCreatingBranches" Message="@createBranchesProgressMessage" />
<LoadingOverlay IsVisible="@isCreatingBranch" Message="@createBranchMessage" />
<LoadingOverlay IsVisible="@isSyncingToDefault" Message="@syncToDefaultMessage" />

@code {
    [Parameter] public int WorkspaceId { get; set; }

    private WorkspaceModel? workspace;
    private List<WorkspaceRepositoryLink> workspaceRepositories = new();
    private IReadOnlyDictionary<int, RepoGitVersionInfo> repoGitInfos = new Dictionary<int, RepoGitVersionInfo>();
    private string? errorMessage;
    private bool isLoading = true;
    private bool isSyncing = false;
    private string syncProgressMessage = "Synchronizing...";
    private bool isUpdating = false;
    private string updateProgressMessage = "Updating dependencies...";
    private CancellationTokenSource? _updateCts;
    private bool isPushing = false;
    private string pushProgressMessage = "Pushing...";
    private CancellationTokenSource? _pushCts;
    private bool showPushWithDependenciesModal = false;
    private PushDependencyInfoForRepo? pushWithDependenciesInfo = null;
    private IReadOnlySet<int>? pushWithDependenciesRepoIdsToPush = null;
    private int pushWithDependenciesRepoId;
    private string? pushWithDependenciesBranchName;
    private string? pushWithDependenciesRepoName;
    private IReadOnlySet<int>? pushPlanRepoIds = null;
    private bool? isOutOfSync = null;
    private bool hasUnmatchedDependencies => workspaceRepositories.Any(wr => (wr.UnmatchedDeps ?? 0) > 0);
    private bool isPushRecommended => workspaceRepositories.Any(wr => (wr.OutgoingCommits ?? 0) > 0 || wr.BranchHasUpstream == false);
    private IEnumerable<IGrouping<int?, WorkspaceRepositoryLink>> LevelGroups =>
        workspaceRepositories
            .GroupBy(wr => wr.DependencyLevel)
            .OrderByDescending(g => g.Key ?? int.MinValue);

    private List<WorkspaceRepositoryLink> FilteredWorkspaceRepositories => GetFilteredWorkspaceRepositories();

    private IEnumerable<IGrouping<int?, WorkspaceRepositoryLink>> FilteredLevelGroups =>
        FilteredWorkspaceRepositories
            .GroupBy(wr => wr.DependencyLevel)
            .OrderByDescending(g => g.Key ?? int.MinValue);
    private Dictionary<int, RepoSyncStatus> repoSyncStatus = new();
    private CancellationTokenSource? _syncCts;
    private bool isCommitSyncing = false;
    private string commitSyncProgressMessage = "Synchronizing commits...";
    private CancellationTokenSource? _commitSyncCts;
    private bool isCheckingOut = false;
    private string checkoutProgressMessage = "Checking out branch...";
    private CancellationTokenSource? _checkoutCts;
    private Dictionary<int, string> repositoryErrors = new(); // repositoryId -> error message
    private HashSet<string> clickedVersions = new(); // Track clicked versions to hide hover until mouse leaves
    private HubConnection? _hubConnection;
    private bool showRepositoriesModal;
    private bool isSavingRepositories;
    private bool isPersisting;
    private bool hasConnectors;
    private string? repositoriesModalErrorMessage;
    private List<GitHubRepositoryEntry>? repositoriesModalRepositories;
    private HashSet<int> selectedRepositoryIds = new();
    private int? fetchedRepositoryCount;
    private CancellationTokenSource? _fetchRepositoriesCts;
    private bool showSwitchBranchModal = false;
    private int switchBranchRepositoryId;
    private string? switchBranchRepositoryName;
    private string? switchBranchCurrentBranch;
    private string? switchBranchRepositoryUrl;
    private bool showBranchModal = false;
    private IReadOnlyList<string> branchModalCommonBranches = Array.Empty<string>();
    private string branchModalDefaultDisplayText = "multiple";
    private bool isCreatingBranches = false;
    private string createBranchesProgressMessage = "Creating branches...";
    private CancellationTokenSource? _createBranchesCts;
    private bool isCreatingBranch = false;
    private string createBranchMessage = "";
    private bool isSyncingToDefault = false;
    private string syncToDefaultMessage = "";
    private bool showUpdateModal = false;
    private bool showUpdateSingleRepoDependenciesModal = false;
    private SyncDependenciesRepoPayload? updateSingleRepoDependenciesPayload = null;
    private int updateSingleRepoDependenciesRepositoryId;
    private string? updateSingleRepoDependenciesRepoName;
    private bool updatePlanIsMultiLevel = false;
    private bool showConfirmModal = false;
    private string confirmModalMessage = "";
    private Func<Task>? _pendingConfirmAction;
    private string searchTerm = string.Empty;

    /// <summary>When true, the grid shows the checkbox column for selecting repositories. Selection is persisted per workspace.</summary>
    private bool showSelectionColumn = false;
    /// <summary>True after we've loaded selection from storage so we can render the grid with the correct checkbox column from the first paint.</summary>
    private bool _selectionStateLoaded = false;
    /// <summary>Repository IDs selected in the grid (when showSelectionColumn is true). Persisted to localStorage per workspace.</summary>
    private HashSet<int> gridSelectedRepositoryIds = new();
    private const string StorageKeyPrefix = "graymoon-ws-";
    private const string StorageKeySuffix = "-selected-repos";
    private const string StorageKeyShowSelectionSuffix = "-show-selection";

    /// <summary>When any repositories are selected (and in selection mode), actions run only on these; otherwise null means all workspace repos.</summary>
    private IReadOnlySet<int>? EffectiveActionRepositoryIds => showSelectionColumn && gridSelectedRepositoryIds.Count > 0
        ? gridSelectedRepositoryIds
        : null;

    protected override async Task OnInitializedAsync()
    {
        await LoadWorkspaceAsync();
        ApplySyncStateFromWorkspace();
        await LoadGridSelectionFromStorageAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try { await JSRuntime.InvokeVoidAsync("focusElement", "workspace-repos-search"); } catch { /* ignore */ }
        }
        if (firstRender && workspace != null && errorMessage == null)
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/hubs/workspace-sync"))
                .WithAutomaticReconnect()
                .Build();
            _hubConnection.On<int>("WorkspaceSynced", async (workspaceId) =>
            {
                if (workspaceId == WorkspaceId)
                    await InvokeAsync(RefreshFromSync);
            });
            await _hubConnection.StartAsync();
        }
    }

    private void ApplySyncStateFromWorkspace()
    {
        if (workspace == null || workspaceRepositories.Count == 0)
        {
            return;
        }
        repoSyncStatus = workspaceRepositories
            .Where(wr => wr.Repository != null)
            .ToDictionary(wr => wr.RepositoryId, wr => wr.SyncStatus);
        isOutOfSync = repoSyncStatus.Values.Any(s => s != RepoSyncStatus.InSync);
        StateHasChanged();
    }

    public void Dispose()
    {
        _ = _hubConnection?.StopAsync();
        _hubConnection?.DisposeAsync();
        _syncCts?.Cancel();
        _syncCts?.Dispose();
        _updateCts?.Cancel();
        _updateCts?.Dispose();
        _pushCts?.Cancel();
        _pushCts?.Dispose();
        _commitSyncCts?.Cancel();
        _commitSyncCts?.Dispose();
        _fetchRepositoriesCts?.Cancel();
        _fetchRepositoriesCts?.Dispose();
        _createBranchesCts?.Cancel();
        _createBranchesCts?.Dispose();
    }

    /// <summary>Called when WorkspaceSynced is received (or after Update): reload from a fresh scope so the grid gets current DB values (no stale DbContext).</summary>
    private async Task RefreshFromSync()
    {
        if (isSyncing || isUpdating)
            return;
        await ReloadWorkspaceDataFromFreshScopeAsync();
        ApplySyncStateFromWorkspace();
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadWorkspaceAsync()
    {
        try
        {
            isLoading = true;
            errorMessage = null;
            await ReloadWorkspaceDataAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading workspace {WorkspaceId}", WorkspaceId);
            errorMessage = "Failed to load workspace. Please try again later.";
            workspaceRepositories = new List<WorkspaceRepositoryLink>();
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task ReloadWorkspaceDataAsync()
    {
        workspace = await WorkspaceRepository.GetByIdAsync(WorkspaceId);
        if (workspace == null)
        {
            errorMessage = "Workspace not found.";
            workspaceRepositories = new List<WorkspaceRepositoryLink>();
            return;
        }

        workspaceRepositories = workspace.Repositories
            .OrderByDescending(wr => wr.DependencyLevel ?? int.MinValue)
            .ThenByDescending(wr => wr.Dependencies ?? int.MinValue)
            .ToList();
    }

    /// <summary>Reload workspace after abort/cancel using a fresh scope. Swallows ObjectDisposedException and InvalidOperationException so abort does not cascade errors when the circuit or context is already disposed.</summary>
    private async Task ReloadWorkspaceDataAfterCancelAsync()
    {
        try
        {
            await ReloadWorkspaceDataFromFreshScopeAsync();
        }
        catch (ObjectDisposedException ex)
        {
            Logger.LogDebug(ex, "Reload after cancel skipped (context disposed) for workspace {WorkspaceId}", WorkspaceId);
        }
        catch (InvalidOperationException ex)
        {
            Logger.LogDebug(ex, "Reload after cancel skipped (invalid operation, e.g. circuit disposed) for workspace {WorkspaceId}", WorkspaceId);
        }
        ApplySyncStateFromWorkspace();
        await InvokeAsync(StateHasChanged);
    }

    /// <summary>Loads workspace using a new scope (fresh DbContext) so we get current DB values and avoid EF cache. Used by RefreshFromSync so the grid shows updated UnmatchedDeps after notify or Update.</summary>
    private async Task ReloadWorkspaceDataFromFreshScopeAsync()
    {
        await using var scope = ServiceScopeFactory.CreateAsyncScope();
        var repo = scope.ServiceProvider.GetRequiredService<WorkspaceRepository>();
        var w = await repo.GetByIdAsync(WorkspaceId);
        if (w == null)
        {
            errorMessage = "Workspace not found.";
            workspaceRepositories = new List<WorkspaceRepositoryLink>();
            return;
        }
        workspace = w;
        workspaceRepositories = workspace.Repositories
            .OrderByDescending(wr => wr.DependencyLevel ?? int.MinValue)
            .ThenByDescending(wr => wr.Dependencies ?? int.MinValue)
            .ToList();
    }

    private RenderFragment GetCommitsBadge(int repositoryId, int? outgoing, int? incoming, bool? branchHasUpstream, string? branchName) => builder =>
    {
        var x = outgoing ?? 0;
        var y = branchHasUpstream == false ? 0 : (incoming ?? 0);
        if (!outgoing.HasValue && !incoming.HasValue && branchHasUpstream != false)
        {
            builder.AddContent(0, "-");
            return;
        }
        string bgColor;
        string textColor = "#fff";
        bool hasCommits = (y > 0) || (x > 0);
        bool notUpstreamed = branchHasUpstream == false;
        if (y > 0)
            bgColor = "#dc3545";   // red: need to pull
        else if (x > 0 || notUpstreamed)
        {
            bgColor = "#ffc107";   // yellow: need to push or new branch not upstreamed
            textColor = "#000";
        }
        else
            bgColor = "#198754";   // green: in sync (0,0)

        var cssClass = notUpstreamed ? "badge commits-badge commits-badge-not-upstreamed" : "badge";
        var clickable = hasCommits || notUpstreamed;
        builder.OpenElement(0, "span");
        builder.AddAttribute(1, "class", cssClass);
        builder.AddAttribute(2, "style", $"background-color: {bgColor}; color: {textColor};{(clickable ? " cursor: pointer;" : "")}");
        if (clickable)
        {
            if (notUpstreamed)
            {
                builder.AddAttribute(3, "onclick", EventCallback.Factory.Create<Microsoft.AspNetCore.Components.Web.MouseEventArgs>(this, () => OnPushBadgeClickAsync(repositoryId, branchName)));
                builder.AddAttribute(4, "title", "Push to set upstream");
            }
            else
            {
                builder.AddAttribute(3, "onclick", EventCallback.Factory.Create<Microsoft.AspNetCore.Components.Web.MouseEventArgs>(this, () => OnPushBadgeClickAsync(repositoryId, branchName)));
                builder.AddAttribute(4, "title", "Click to push");
            }
        }
        if (notUpstreamed)
        {
            builder.OpenElement(5, "span");
            builder.AddAttribute(6, "class", "commits-badge-icon-up commits-badge-icon-up--black");
            builder.OpenElement(7, "i");
            builder.AddAttribute(8, "class", "bi bi-cloud-arrow-up");
            builder.AddAttribute(9, "aria-hidden", "true");
            builder.CloseElement();
            builder.CloseElement();
        }
        else
        {
            builder.AddContent(5, $"↑{x} ↓{y}");
        }
        builder.CloseElement();
    };

    private RenderFragment GetRepoSyncBadge(int repositoryId) => builder =>
    {
        if (repoSyncStatus.TryGetValue(repositoryId, out var status))
        {
            var (text, bgColor) = status switch
            {
                // In-sync badge: match primary Sync button blue
                RepoSyncStatus.InSync => ("in sync", "#0e639c"),
                RepoSyncStatus.NeedsSync => ("sync", "#dc3545"),
                RepoSyncStatus.NotCloned => ("not cloned", "#6c757d"),
                RepoSyncStatus.VersionMismatch => ("version", "#dc3545"),
                RepoSyncStatus.Error => ("error", "#dc3545"),
                _ => ("sync", "#6c757d")
            };
            var needsSync = status != RepoSyncStatus.InSync;
            var clickable = needsSync && !isSyncing;
            builder.OpenElement(0, "span");
            builder.AddAttribute(1, "class", "badge");
            builder.AddAttribute(2, "style", $"background-color: {bgColor}; color: #fff;{(clickable ? " cursor: pointer;" : "")}");
            if (clickable)
            {
                builder.AddAttribute(3, "onclick", EventCallback.Factory.Create(this, () => SyncSingleRepoAsync(repositoryId)));
                builder.AddAttribute(4, "title", "Click to sync this repository");
                builder.AddContent(5, text);
            }
            else
            {
                builder.AddContent(3, text);
            }
            builder.CloseElement();
        }
    };

    private void AbortSyncAsync()
    {
        _syncCts?.Cancel();
    }

    private void AbortUpdateAsync()
    {
        _updateCts?.Cancel();
    }

    /// <summary>
    /// Attempts to update all configured file versions at the end of an update workflow.
    /// Shows a toast for each file that was updated; logs warnings on failure and skips gracefully when no files are configured.
    /// </summary>
    private async Task TryUpdateFileVersionsAsync()
    {
        try
        {
            var (_, _, error) = await FileVersionService.UpdateAllVersionsAsync(
                WorkspaceId,
                selectedRepositoryIds: null,
                onFileUpdated: filePath => ToastService.Show($"File {filePath} updated."));
            if (error != null && !error.Contains("No version configurations"))
                Logger.LogWarning("Auto file-version update after dependency update: {Error}", error);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Auto file-version update failed after dependency update for workspace {WorkspaceId}", WorkspaceId);
        }
    }

    private void AbortPushAsync()
    {
        _pushCts?.Cancel();
    }


    private void AbortCommitSyncAsync()
    {
        _commitSyncCts?.Cancel();
    }

    private void CloseUpdateModal()
    {
        showUpdateModal = false;
        StateHasChanged();
    }

    private void CloseConfirmModal()
    {
        showConfirmModal = false;
        _pendingConfirmAction = null;
        StateHasChanged();
    }

    private async Task OnConfirmModalYesAsync()
    {
        var action = _pendingConfirmAction;
        CloseConfirmModal();
        if (action != null)
            await action();
    }

    private void ShowConfirm(string message, Func<Task> onConfirm)
    {
        confirmModalMessage = message;
        _pendingConfirmAction = onConfirm;
        showConfirmModal = true;
        StateHasChanged();
    }

    private void ShowConfirmOpenPr(int count, IReadOnlyList<string?> urls)
    {
        async Task OpenPrAsync()
        {
            var list = urls.Where(u => !string.IsNullOrEmpty(u)).Cast<string>().ToList();
            await JSRuntime.InvokeVoidAsync("graymoonOpenUrls", list);
        }
        if (count <= 1)
            _ = OpenPrAsync();
        else
            ShowConfirm($"Do you want to open pull request for {count} repositories?", OpenPrAsync);
    }

    private void ShowConfirmSyncCommitsLevel(List<int> repositoryIds)
    {
        if (repositoryIds.Count <= 1)
            _ = CommitSyncLevelAsync(repositoryIds);
        else
            ShowConfirm($"Do you want to sync commits for {repositoryIds.Count} repositories?", () => CommitSyncLevelAsync(repositoryIds));
    }

    private void ShowConfirmOpenGitHub(int count, IReadOnlyList<string?> urls)
    {
        async Task OpenGitHubAsync()
        {
            var list = urls.Where(u => !string.IsNullOrEmpty(u)).Cast<string>().ToList();
            await JSRuntime.InvokeVoidAsync("graymoonOpenUrls", list);
        }
        if (count <= 1)
            _ = OpenGitHubAsync();
        else
            ShowConfirm($"Do you want to open GitHub page for {count} repositories?", OpenGitHubAsync);
    }

    private async Task ShowConfirmUpdateDependenciesAsync(int repositoryId, int unmatchedCount)
    {
        if (workspace == null || isUpdating || isSyncing)
            return;
        try
        {
            await using var scope = ServiceScopeFactory.CreateAsyncScope();
            var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
            var (payload, _) = await workspaceGitService.GetUpdatePlanAsync(WorkspaceId, new HashSet<int> { repositoryId });
            if (payload == null || payload.Count == 0)
            {
                ToastService.Show("No dependency updates for this repository.");
                return;
            }
            var repoPayload = payload[0];
            var repoName = workspaceRepositories.FirstOrDefault(wr => wr.RepositoryId == repositoryId)?.Repository?.RepositoryName;
            updateSingleRepoDependenciesPayload = repoPayload;
            updateSingleRepoDependenciesRepositoryId = repositoryId;
            updateSingleRepoDependenciesRepoName = repoName;
            showUpdateSingleRepoDependenciesModal = true;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting update plan for repository {RepositoryId}", repositoryId);
            ToastService.Show("Could not load dependency updates.");
        }
    }

    private void CloseUpdateSingleRepositoryDependenciesModal()
    {
        showUpdateSingleRepoDependenciesModal = false;
        updateSingleRepoDependenciesPayload = null;
    }

    private void OnCommitDependencyProgress(int current, int total, int unused)
    {
        updateProgressMessage = $"Committed {current} of {total}";
        _ = InvokeAsync(StateHasChanged);
    }

    private async Task OnUpdateSingleRepositoryDependenciesProceedAsync(bool commitVersionUpdate)
    {
        if (updateSingleRepoDependenciesPayload == null)
            return;
        var repositoryId = updateSingleRepoDependenciesRepositoryId;
        var payloadToCommit = updateSingleRepoDependenciesPayload;
        CloseUpdateSingleRepositoryDependenciesModal();

        _updateCts?.Cancel();
        _updateCts?.Dispose();
        _updateCts = new CancellationTokenSource();
        isUpdating = true;
        updateProgressMessage = "Updating repository...";
        repositoryErrors.Remove(repositoryId);
        try
        {
            await InvokeAsync(StateHasChanged);
            await using (var scope = ServiceScopeFactory.CreateAsyncScope())
            {
                var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
                await workspaceGitService.RunUpdateSingleRepositoryAsync(
                    WorkspaceId,
                    repositoryId,
                    onProgressMessage: msg => { updateProgressMessage = msg; _ = InvokeAsync(StateHasChanged); },
                    onRepoError: (repoId, msg) => { repositoryErrors[repoId] = msg; _ = InvokeAsync(StateHasChanged); },
                    cancellationToken: _updateCts.Token);

                if (commitVersionUpdate)
                {
                    updateProgressMessage = "Committing version update...";
                    await InvokeAsync(StateHasChanged);
                    var commitResults = await workspaceGitService.CommitDependencyUpdatesAsync(
                        WorkspaceId,
                        new[] { payloadToCommit },
                        onProgress: OnCommitDependencyProgress,
                        cancellationToken: _updateCts.Token);
                    var err = commitResults.FirstOrDefault(r => r.RepoId == repositoryId).ErrorMessage;
                    if (err != null)
                        ToastService.Show(err);
                }
            }
            await TryUpdateFileVersionsAsync();
            await RefreshFromSync();
        }
        catch (OperationCanceledException)
        {
            ToastService.Show("Update cancelled.");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Update dependencies failed for repository {RepositoryId}", repositoryId);
            ToastService.Show(ex.Message);
        }
        finally
        {
            isUpdating = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void ShowConfirmSyncCommits(int repositoryId)
    {
        ShowConfirm("Do you want to sync commits for this repository?", () => CommitSyncAsync(repositoryId));
    }

    /// <summary>When user clicks the not-upstreamed badge: check dependencies. No deps = push directly; has deps = show modal with dependency list and Synchronized Push option.</summary>
    private async Task OnPushBadgeClickAsync(int repositoryId, string? branchName)
    {
        if (workspace == null || isPushing || isSyncing || isUpdating)
            return;

        try
        {
            await using var scope = ServiceScopeFactory.CreateAsyncScope();
            var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
            var depInfo = await workspaceGitService.GetPushDependencyInfoForRepoAsync(WorkspaceId, repositoryId);

            if (depInfo == null || depInfo.DependencyRepoIds.Count == 0)
            {
                await PushSingleRepositoryWithUpstreamAsync(repositoryId, branchName);
                return;
            }

            var repoName = workspaceRepositories.FirstOrDefault(wr => wr.RepositoryId == repositoryId)?.Repository?.RepositoryName;
            pushWithDependenciesInfo = depInfo;
            pushWithDependenciesRepoIdsToPush = null;
            pushWithDependenciesRepoId = repositoryId;
            pushWithDependenciesBranchName = branchName;
            pushWithDependenciesRepoName = repoName;
            showPushWithDependenciesModal = true;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting push dependency info for repository {RepositoryId}", repositoryId);
            ToastService.Show("Could not load dependency info. Try again.");
        }
    }

    private void ClosePushWithDependenciesModal()
    {
        showPushWithDependenciesModal = false;
        pushWithDependenciesInfo = null;
        pushWithDependenciesRepoIdsToPush = null;
    }

    /// <summary>Proceed from PushWithDependencies modal: either level-order push (no sync) or synchronized push (sync registries then level-order push with wait).</summary>
    private async Task OnPushWithDependenciesProceedAsync(bool synchronizedPush)
    {
        if (pushWithDependenciesInfo == null || workspace == null)
            return;

        var repoIds = pushWithDependenciesRepoIdsToPush != null
            ? pushWithDependenciesRepoIdsToPush
            : pushWithDependenciesInfo.DependencyRepoIds.Concat(new[] { pushWithDependenciesRepoId }).ToHashSet();
        var requiredPackageIds = pushWithDependenciesInfo.PayloadForRepo.RequiredPackages
            .Select(r => r.PackageId?.Trim())
            .Where(id => !string.IsNullOrEmpty(id))
            .Cast<string>()
            .ToHashSet(StringComparer.OrdinalIgnoreCase);
        ClosePushWithDependenciesModal();

        _pushCts?.Cancel();
        _pushCts?.Dispose();
        _pushCts = new CancellationTokenSource();
        isPushing = true;

        try
        {
            await using var scope = ServiceScopeFactory.CreateAsyncScope();
            var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();

            if (synchronizedPush)
            {
                pushProgressMessage = "Syncing package registries for required packages...";
                await InvokeAsync(StateHasChanged);
                if (requiredPackageIds.Count > 0 && scope.ServiceProvider.GetService<PackageRegistrySyncService>() is { } syncService)
                    await syncService.SyncRegistriesForPackageIdsAsync(WorkspaceId, requiredPackageIds, _pushCts.Token);
                pushProgressMessage = "Pushing (synchronized)...";
                await InvokeAsync(StateHasChanged);
                await workspaceGitService.RunPushAsync(WorkspaceId, repoIds, msg => { pushProgressMessage = msg; _ = InvokeAsync(StateHasChanged); }, (id, err) => ToastService.Show($"{id}: {err}"), _pushCts.Token);
            }
            else
            {
                pushProgressMessage = "Pushing...";
                await workspaceGitService.RunPushReposInLevelOrderAsync(WorkspaceId, repoIds, msg => { pushProgressMessage = msg; _ = InvokeAsync(StateHasChanged); }, (id, err) => ToastService.Show($"{id}: {err}"), _pushCts.Token);
            }

            await RefreshFromSync();
        }
        catch (OperationCanceledException)
        {
            ToastService.Show("Push cancelled.");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Push with dependencies failed");
            ToastService.Show(ex.Message);
        }
        finally
        {
            isPushing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    /// <summary>Push with upstream for a single repository (e.g. when user clicks the not-upstreamed badge). Uses the page overlay.</summary>
    private async Task PushSingleRepositoryWithUpstreamAsync(int repositoryId, string? branchName)
    {
        if (workspace == null || isPushing || isSyncing || isUpdating)
            return;

        _pushCts?.Cancel();
        _pushCts?.Dispose();
        _pushCts = new CancellationTokenSource();
        isPushing = true;
        pushProgressMessage = "Setting upstream...";

        try
        {
            await using var scope = ServiceScopeFactory.CreateAsyncScope();
            var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
            var (success, errorMessage) = await workspaceGitService.PushSingleRepositoryWithUpstreamAsync(
                WorkspaceId,
                repositoryId,
                branchName,
                msg => { pushProgressMessage = msg; _ = InvokeAsync(StateHasChanged); },
                _pushCts.Token);

            if (success)
                await RefreshFromSync();
            else
                ToastService.Show(errorMessage ?? "Push failed.");
        }
        catch (OperationCanceledException)
        {
            ToastService.Show("Push cancelled.");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Push with upstream failed for repository {RepositoryId}", repositoryId);
            ToastService.Show(ex.Message);
        }
        finally
        {
            isPushing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    /// <summary>Push button click: get push plan; filter to repos with unpushed commits or no upstream branch; if selection active filter to selected; if more than one repo show confirmation modal; else run push directly.</summary>
    private async Task OnPushClickAsync()
    {
        if (workspace == null || workspaceRepositories.Count == 0 || isPushing || isSyncing || isUpdating)
            return;

        try
        {
            await using var scope = ServiceScopeFactory.CreateAsyncScope();
            var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
            var (payload, _) = await workspaceGitService.GetPushPlanAsync(WorkspaceId);
            var repoIdsWithUnpushed = workspaceRepositories
                .Where(wr => (wr.OutgoingCommits ?? 0) > 0 || wr.BranchHasUpstream == false)
                .Select(wr => wr.RepositoryId)
                .ToHashSet();
            if (EffectiveActionRepositoryIds != null)
                repoIdsWithUnpushed = repoIdsWithUnpushed.Where(EffectiveActionRepositoryIds.Contains).ToHashSet();
            var toPush = payload.Where(p => repoIdsWithUnpushed.Contains(p.RepoId)).ToList();
            if (toPush.Count == 0)
            {
                ToastService.Show("No repositories to push.");
                return;
            }
            pushPlanRepoIds = repoIdsWithUnpushed;
            var depInfo = await workspaceGitService.GetPushDependencyInfoForRepoSetAsync(WorkspaceId, pushPlanRepoIds);
            if (depInfo == null)
            {
                ToastService.Show("Could not load push plan. Try again.");
                return;
            }
            pushWithDependenciesInfo = depInfo;
            pushWithDependenciesRepoIdsToPush = pushPlanRepoIds;
            pushWithDependenciesRepoId = 0;
            pushWithDependenciesRepoName = null;
            showPushWithDependenciesModal = true;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting push plan for workspace {WorkspaceId}", WorkspaceId);
            errorMessage = "Could not determine push plan. The GrayMoon Agent may be offline.";
        }
    }

    /// <summary>Update button click: get update plan; if no updates, toast; else show modal (single vs multi-level).</summary>
    private async Task OnUpdateClickAsync()
    {
        if (workspace == null || workspaceRepositories.Count == 0 || isUpdating || isSyncing)
            return;

        try
        {
            await using var scope = ServiceScopeFactory.CreateAsyncScope();
            var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
            var (payload, isMultiLevel) = await workspaceGitService.GetUpdatePlanAsync(WorkspaceId);
            if (payload.Count == 0)
            {
                ToastService.Show("No dependency updates required.");
                await TryUpdateFileVersionsAsync();
                return;
            }
            updatePlanIsMultiLevel = isMultiLevel;
            showUpdateModal = true;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error getting update plan for workspace {WorkspaceId}", WorkspaceId);
            errorMessage = "Could not determine update plan. The GrayMoon Agent may be offline.";
        }
    }

    private async Task OnUpdateProceedAsync()
    {
        CloseUpdateModal();
        await RunUpdateCoreAsync(withCommits: true);
    }

    private async Task OnUpdateOnlyAsync()
    {
        CloseUpdateModal();
        await RunUpdateCoreAsync(withCommits: false);
    }

    /// <summary>Runs update (refresh, sync deps, optional commits). Overlay shows progress.</summary>
    private async Task RunUpdateCoreAsync(bool withCommits)
    {
        if (workspace == null || workspaceRepositories.Count == 0 || isUpdating || isSyncing)
            return;

        _updateCts?.Cancel();
        _updateCts?.Dispose();
        _updateCts = new CancellationTokenSource();

        isUpdating = true;
        var updateCount = EffectiveActionRepositoryIds?.Count ?? 0;
        updateProgressMessage = updateCount > 0
            ? $"Updating {updateCount} {(updateCount == 1 ? "repository" : "repositories")}..."
            : "Updating dependencies...";
        errorMessage = null;
        try
        {
            StateHasChanged();
            await Task.Yield();

            await using (var scope = ServiceScopeFactory.CreateAsyncScope())
            {
                var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
                await workspaceGitService.RunUpdateAsync(
                    WorkspaceId,
                    withCommits,
                    onProgressMessage: msg =>
                    {
                        updateProgressMessage = msg;
                        InvokeAsync(StateHasChanged);
                    },
                    onRepoError: (repoId, msg) =>
                    {
                        repositoryErrors[repoId] = msg;
                        InvokeAsync(StateHasChanged);
                    },
                    repoIdsToUpdate: EffectiveActionRepositoryIds,
                    cancellationToken: _updateCts.Token);
            }

            isUpdating = false;
            await InvokeAsync(StateHasChanged);
            await TryUpdateFileVersionsAsync();
            await RefreshFromSync();
        }
        catch (OperationCanceledException)
        {
            isUpdating = false;
            await ReloadWorkspaceDataAfterCancelAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating dependencies for workspace {WorkspaceId}", WorkspaceId);
            errorMessage = "Update failed. The GrayMoon Agent may be offline. Start the Agent and try again.";
        }
        finally
        {
            isUpdating = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task HandleDependencyBadgeKeydown(KeyboardEventArgs e, int repositoryId, int unmatchedDeps)
    {
        if ((e.Key == "Enter" || e.Key == " ") && !isUpdating && !isSyncing)
            await ShowConfirmUpdateDependenciesAsync(repositoryId, unmatchedDeps);
    }

    /// <summary>Update dependencies for a single repository only (refresh projects, sync deps, no commit). Same as Update but scoped to one repo.</summary>
    private async Task UpdateSingleRepositoryAsync(int repositoryId)
    {
        if (workspace == null || isUpdating || isSyncing)
            return;

        _updateCts?.Cancel();
        _updateCts?.Dispose();
        _updateCts = new CancellationTokenSource();

        isUpdating = true;
        updateProgressMessage = "Updating repository...";
        errorMessage = null;
        repositoryErrors.Remove(repositoryId);
        try
        {
            StateHasChanged();
            await Task.Yield();

            await using (var scope = ServiceScopeFactory.CreateAsyncScope())
            {
                var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
                await workspaceGitService.RunUpdateSingleRepositoryAsync(
                    WorkspaceId,
                    repositoryId,
                    onProgressMessage: msg =>
                    {
                        updateProgressMessage = msg;
                        InvokeAsync(StateHasChanged);
                    },
                    onRepoError: (repoId, msg) =>
                    {
                        repositoryErrors[repoId] = msg;
                        InvokeAsync(StateHasChanged);
                    },
                    cancellationToken: _updateCts.Token);
            }

            isUpdating = false;
            await InvokeAsync(StateHasChanged);
            await TryUpdateFileVersionsAsync();
            await RefreshFromSync();
        }
        catch (OperationCanceledException)
        {
            isUpdating = false;
            await ReloadWorkspaceDataAfterCancelAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating repository {RepositoryId} in workspace {WorkspaceId}", repositoryId, WorkspaceId);
            repositoryErrors[repositoryId] = "Update failed. The GrayMoon Agent may be offline. Start the Agent and try again.";
        }
        finally
        {
            isUpdating = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ShowRepositoriesModalAsync()
    {
        if (workspace == null)
        {
            return;
        }
        repositoriesModalErrorMessage = null;
        selectedRepositoryIds = workspace.Repositories
            .Select(link => link.RepositoryId)
            .ToHashSet();
        await EnsureRepositoriesForModalAsync();
        showRepositoriesModal = true;
    }

    private async Task EnsureRepositoriesForModalAsync()
    {
        var connectors = await ConnectorRepository.GetAllAsync();
        hasConnectors = connectors.Count > 0;
        if (repositoriesModalRepositories == null && hasConnectors)
        {
            repositoriesModalRepositories = await RepositoryService.GetPersistedRepositoriesAsync();
        }
    }

    private void CloseRepositoriesModal()
    {
        showRepositoriesModal = false;
        repositoriesModalErrorMessage = null;
    }

    private async Task SaveRepositoriesAsync()
    {
        if (workspace == null || isSavingRepositories)
        {
            return;
        }
        if (selectedRepositoryIds.Count == 0)
        {
            repositoriesModalErrorMessage = "Select at least one repository.";
            return;
        }
        isSavingRepositories = true;
        repositoriesModalErrorMessage = null;
        await InvokeAsync(StateHasChanged);
        try
        {
            await WorkspaceRepository.UpdateAsync(WorkspaceId, workspace.Name, selectedRepositoryIds);
            CloseRepositoriesModal();
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving repositories for workspace {WorkspaceId}", WorkspaceId);
            repositoriesModalErrorMessage = ex.Message;
        }
        finally
        {
            isSavingRepositories = false;
        }
    }

    private void AbortFetchRepositories()
    {
        _fetchRepositoriesCts?.Cancel();
    }

    private async Task FetchRepositoriesAsync()
    {
        if (!hasConnectors || isPersisting)
        {
            return;
        }
        _fetchRepositoriesCts?.Cancel();
        _fetchRepositoriesCts = new CancellationTokenSource();
        try
        {
            isPersisting = true;
            fetchedRepositoryCount = null;
            repositoriesModalErrorMessage = null;
            await InvokeAsync(StateHasChanged);
            var progress = new Progress<int>(count =>
            {
                fetchedRepositoryCount = count;
                _ = InvokeAsync(StateHasChanged);
            });
            var result = await RepositoryService.RefreshRepositoriesAsync(progress, _fetchRepositoriesCts.Token);
            repositoriesModalRepositories = result.Repositories.ToList();
        }
        catch (OperationCanceledException)
        {
            repositoriesModalRepositories = await RepositoryService.GetPersistedRepositoriesAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error fetching repositories");
            repositoriesModalErrorMessage = "Failed to fetch repositories. Please try again later.";
            repositoriesModalRepositories = new List<GitHubRepositoryEntry>();
        }
        finally
        {
            isPersisting = false;
        }
    }

    /// <summary>Sync repos only (git, version, branch, commit counts). Does not read or write .csproj; dependency mismatches are resolved only by Update. Runs in a fresh scope so DbContext is not stale and PersistVersionsAsync → dependency recompute sees current state.</summary>
    private async Task SyncAsync()
    {
        if (workspace == null || workspaceRepositories.Count == 0 || isSyncing)
        {
            return;
        }

        _syncCts?.Cancel();
        _syncCts = new CancellationTokenSource();

        isSyncing = true;
        var syncCount = EffectiveActionRepositoryIds?.Count ?? 0;
        syncProgressMessage = syncCount > 0
            ? $"Synchronizing {syncCount} {(syncCount == 1 ? "repository" : "repositories")}..."
            : "Synchronizing...";
        var isRetryAfterError = !string.IsNullOrEmpty(errorMessage);
        errorMessage = null;
        try
        {
            StateHasChanged();
            await Task.Yield();

            await using (var scope = ServiceScopeFactory.CreateAsyncScope())
            {
                var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
                var results = await workspaceGitService.SyncAsync(
                    WorkspaceId,
                    onProgress: (completed, total, repoId, info) =>
                    {
                        syncProgressMessage = $"Synchronized {completed} of {total}";
                        repoSyncStatus[repoId] = (info.Version == "-" && info.Branch == "-")
                            ? RepoSyncStatus.Error
                            : RepoSyncStatus.InSync;
                        var wr = workspaceRepositories.FirstOrDefault(w => w.RepositoryId == repoId);
                        if (wr != null)
                        {
                            wr.GitVersion = info.Version == "-" ? null : info.Version;
                            wr.BranchName = info.Branch == "-" ? null : info.Branch;
                            wr.Projects = info.Projects;
                            wr.OutgoingCommits = info.OutgoingCommits;
                            wr.IncomingCommits = info.IncomingCommits;
                        }
                        InvokeAsync(StateHasChanged);
                    },
                    repositoryIds: EffectiveActionRepositoryIds != null ? EffectiveActionRepositoryIds.ToList() : null,
                    skipDependencyLevelPersistence: EffectiveActionRepositoryIds != null || isRetryAfterError,
                    cancellationToken: _syncCts.Token);
                repoGitInfos = results;
            }
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
            isOutOfSync = repoSyncStatus.Values.Any(v => v != RepoSyncStatus.InSync);

            // Set per-repo errors from sync results (same pattern as commit sync and checkout)
            foreach (var (repoId, info) in repoGitInfos)
            {
                if (!string.IsNullOrWhiteSpace(info.ErrorMessage))
                    repositoryErrors[repoId] = info.ErrorMessage;
                else
                    repositoryErrors.Remove(repoId);
            }
        }
        catch (OperationCanceledException)
        {
            // Sync was cancelled - reload workspace to restore pre-sync data (onProgress may have partially updated in-memory state)
            await ReloadWorkspaceDataAfterCancelAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error syncing workspace {WorkspaceId}", WorkspaceId);
            errorMessage = "Sync failed. The GrayMoon Agent may be offline. Start the Agent and try again.";
        }
        finally
        {
            isSyncing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    /// <summary>Sync a single repository (same as Sync button but for one repo).</summary>
    private async Task SyncSingleRepoAsync(int repositoryId)
    {
        if (workspace == null || workspaceRepositories.Count == 0 || isSyncing)
            return;

        _syncCts?.Cancel();
        _syncCts = new CancellationTokenSource();

        isSyncing = true;
        syncProgressMessage = "Synchronizing repository...";
        errorMessage = null;
        try
        {
            StateHasChanged();
            await Task.Yield();

            await using (var scope = ServiceScopeFactory.CreateAsyncScope())
            {
                var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
                var results = await workspaceGitService.SyncAsync(
                    WorkspaceId,
                    onProgress: (completed, total, repoId, info) =>
                    {
                        syncProgressMessage = $"Synchronized {completed} of {total}";
                        repoSyncStatus[repoId] = (info.Version == "-" && info.Branch == "-")
                            ? RepoSyncStatus.Error
                            : RepoSyncStatus.InSync;
                        var wr = workspaceRepositories.FirstOrDefault(w => w.RepositoryId == repoId);
                        if (wr != null)
                        {
                            wr.GitVersion = info.Version == "-" ? null : info.Version;
                            wr.BranchName = info.Branch == "-" ? null : info.Branch;
                            wr.Projects = info.Projects;
                            wr.OutgoingCommits = info.OutgoingCommits;
                            wr.IncomingCommits = info.IncomingCommits;
                        }
                        InvokeAsync(StateHasChanged);
                    },
                    repositoryIds: new[] { repositoryId },
                    skipDependencyLevelPersistence: true,
                    cancellationToken: _syncCts.Token);
                repoGitInfos = results;
            }
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
            isOutOfSync = repoSyncStatus.Values.Any(v => v != RepoSyncStatus.InSync);

            foreach (var (repoId, info) in repoGitInfos)
            {
                if (!string.IsNullOrWhiteSpace(info.ErrorMessage))
                    repositoryErrors[repoId] = info.ErrorMessage;
                else
                    repositoryErrors.Remove(repoId);
            }
        }
        catch (OperationCanceledException)
        {
            await ReloadWorkspaceDataAfterCancelAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error syncing repository {RepositoryId} in workspace {WorkspaceId}", repositoryId, WorkspaceId);
            errorMessage = "Sync failed. The GrayMoon Agent may be offline. Start the Agent and try again.";
        }
        finally
        {
            isSyncing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task CommitSyncAsync(int repositoryId)
    {
        if (workspace == null || isCommitSyncing || isSyncing || isUpdating)
            return;

        _commitSyncCts?.Cancel();
        _commitSyncCts?.Dispose();
        _commitSyncCts = new CancellationTokenSource();

        isCommitSyncing = true;
        commitSyncProgressMessage = "Synchronizing commits...";
        errorMessage = null;
        try
        {
            StateHasChanged();
            await Task.Yield();

            var httpClient = HttpClientFactory.CreateClient();
            var request = new
            {
                repositoryId,
                workspaceId = WorkspaceId
            };
            var json = System.Text.Json.JsonSerializer.Serialize(request);
            var content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");
            
            var baseUrl = NavigationManager.BaseUri.TrimEnd('/');
            var response = await httpClient.PostAsync($"{baseUrl}/api/commitsync", content, _commitSyncCts.Token);

            if (response.IsSuccessStatusCode)
            {
                var responseContent = await response.Content.ReadAsStringAsync(_commitSyncCts.Token);
                var result = System.Text.Json.JsonSerializer.Deserialize<CommitSyncResponse>(responseContent, AgentResponseJson.Options);

                if (result != null && !string.IsNullOrWhiteSpace(result.ErrorMessage))
                {
                    repositoryErrors[repositoryId] = result.ErrorMessage;
                    commitSyncProgressMessage = result.MergeConflict ? "Merge conflict detected. Merge aborted." : "Commit sync completed with errors.";
                    await Task.Delay(2000, _commitSyncCts.Token);
                }
                else if (result != null && result.MergeConflict)
                {
                    commitSyncProgressMessage = "Merge conflict detected. Merge aborted.";
                    await Task.Delay(2000, _commitSyncCts.Token);
                }
                else
                {
                    repositoryErrors.Remove(repositoryId);
                    commitSyncProgressMessage = "Commit sync completed successfully.";
                    await Task.Delay(1000, _commitSyncCts.Token);
                }
            }
            else
            {
                var errorText = await response.Content.ReadAsStringAsync(_commitSyncCts.Token);
                var displayError = TryGetErrorMessageFromResponseBody(errorText) ?? $"Commit sync failed: {response.StatusCode}";
                repositoryErrors[repositoryId] = displayError;
                errorMessage = displayError;
                Logger.LogError("CommitSync failed: {StatusCode}, {Error}", response.StatusCode, errorText);
            }

            // Refresh workspace data to show updated commit counts
            await RefreshFromSync();
        }
        catch (OperationCanceledException)
        {
            // Operation was cancelled
            await ReloadWorkspaceDataAfterCancelAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error syncing commits for repository {RepositoryId}", repositoryId);
            var errorMsg = "Commit sync failed. The GrayMoon Agent may be offline. Start the Agent and try again.";
            repositoryErrors[repositoryId] = errorMsg;
            errorMessage = errorMsg;
        }
        finally
        {
            isCommitSyncing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task CommitSyncLevelAsync(List<int> repositoryIds)
    {
        if (workspace == null || isCommitSyncing || isSyncing || isUpdating || repositoryIds == null || repositoryIds.Count == 0)
            return;

        _commitSyncCts?.Cancel();
        _commitSyncCts?.Dispose();
        _commitSyncCts = new CancellationTokenSource();

        isCommitSyncing = true;
        commitSyncProgressMessage = $"Synchronizing commits for {repositoryIds.Count} {(repositoryIds.Count == 1 ? "repository" : "repositories")}...";
        errorMessage = null;
        try
        {
            StateHasChanged();
            await Task.Yield();

            var httpClient = HttpClientFactory.CreateClient();
            var baseUrl = NavigationManager.BaseUri.TrimEnd('/');

            // Sync all repositories in parallel
            var syncTasks = repositoryIds.Select(async repositoryId =>
            {
                try
                {
                    var request = new
                    {
                        repositoryId,
                        workspaceId = WorkspaceId
                    };
                    var json = System.Text.Json.JsonSerializer.Serialize(request);
                    var content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");
                    var response = await httpClient.PostAsync($"{baseUrl}/api/commitsync", content, _commitSyncCts.Token);

                    if (response.IsSuccessStatusCode)
                    {
                        var responseContent = await response.Content.ReadAsStringAsync(_commitSyncCts.Token);
                        var result = System.Text.Json.JsonSerializer.Deserialize<CommitSyncResponse>(responseContent, AgentResponseJson.Options);

                        if (result != null && !string.IsNullOrWhiteSpace(result.ErrorMessage))
                        {
                            repositoryErrors[repositoryId] = result.ErrorMessage;
                        }
                        else if (result != null && result.MergeConflict)
                        {
                            repositoryErrors[repositoryId] = "Merge conflict detected. Merge aborted.";
                        }
                        else
                        {
                            repositoryErrors.Remove(repositoryId);
                        }
                    }
                    else
                    {
                        var errorText = await response.Content.ReadAsStringAsync(_commitSyncCts.Token);
                        repositoryErrors[repositoryId] = TryGetErrorMessageFromResponseBody(errorText) ?? $"Commit sync failed: {response.StatusCode}";
                        Logger.LogError("CommitSync failed for repository {RepositoryId}: {StatusCode}, {Error}", repositoryId, response.StatusCode, errorText);
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Error syncing commits for repository {RepositoryId}", repositoryId);
                    repositoryErrors[repositoryId] = "Commit sync failed. The GrayMoon Agent may be offline.";
                }
            });

            await Task.WhenAll(syncTasks);

            // Refresh workspace data to show updated commit counts
            await RefreshFromSync();
            commitSyncProgressMessage = "Commit sync completed.";
            await Task.Delay(1000, _commitSyncCts.Token);
        }
        catch (OperationCanceledException)
        {
            // Operation was cancelled
            await ReloadWorkspaceDataAfterCancelAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error syncing commits for level");
            errorMessage = "Commit sync failed. The GrayMoon Agent may be offline. Start the Agent and try again.";
        }
        finally
        {
            isCommitSyncing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void ShowSwitchBranchModal(int repositoryId, string? currentBranch, string? cloneUrl)
    {
        var wr = workspaceRepositories.FirstOrDefault(wr => wr.RepositoryId == repositoryId);
        var repo = wr?.Repository;
        
        if (repo == null)
            return;

        switchBranchRepositoryId = repositoryId;
        switchBranchRepositoryName = repo.RepositoryName;
        switchBranchCurrentBranch = currentBranch;
        // Use cloneUrl if provided, otherwise try to get from repo
        switchBranchRepositoryUrl = cloneUrl ?? repo.CloneUrl;
        showSwitchBranchModal = true;
        StateHasChanged();
    }

    private void CloseSwitchBranchModal()
    {
        showSwitchBranchModal = false;
        switchBranchRepositoryId = 0;
        switchBranchRepositoryName = null;
        switchBranchCurrentBranch = null;
        switchBranchRepositoryUrl = null;
    }

    private async Task ShowBranchModalAsync()
    {
        if (workspace == null || workspaceRepositories.Count == 0)
            return;
        try
        {
            var httpClient = HttpClientFactory.CreateClient();
            var request = new { workspaceId = WorkspaceId };
            var json = JsonSerializer.Serialize(request);
            var content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");
            var baseUrl = NavigationManager.BaseUri.TrimEnd('/');
            var response = await httpClient.PostAsync($"{baseUrl}/api/branches/common", content);
            if (response.IsSuccessStatusCode)
            {
                var responseContent = await response.Content.ReadAsStringAsync();
                var data = JsonSerializer.Deserialize<CommonBranchesApiResult>(responseContent, AgentResponseJson.Options);
                if (data != null)
                {
                    branchModalCommonBranches = data.CommonBranchNames ?? new List<string>();
                    branchModalDefaultDisplayText = data.DefaultDisplayText ?? "multiple";
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Could not load common branches for branch modal");
        }
        showBranchModal = true;
        StateHasChanged();
    }

    private void CloseBranchModal()
    {
        showBranchModal = false;
    }

    private async Task CreateBranchesAsync((string NewBranchName, string BaseBranch) args)
    {
        var (newBranchName, baseBranch) = args;
        if (workspace == null || string.IsNullOrWhiteSpace(newBranchName) || isCreatingBranches || isSyncing || isUpdating)
            return;

        CloseBranchModal();
        _createBranchesCts?.Cancel();
        _createBranchesCts?.Dispose();
        _createBranchesCts = new CancellationTokenSource();

        isCreatingBranches = true;
        var branchCount = EffectiveActionRepositoryIds?.Count ?? 0;
        createBranchesProgressMessage = branchCount > 0
            ? $"Creating branches for {branchCount} {(branchCount == 1 ? "repository" : "repositories")}..."
            : "Creating branches...";
        errorMessage = null;
        StateHasChanged();

        try
        {
            await Task.Yield();
            await using (var scope = ServiceScopeFactory.CreateAsyncScope())
            {
                var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
                await workspaceGitService.CreateBranchesAsync(
                    WorkspaceId,
                    newBranchName,
                    baseBranch,
                    onProgress: (completed, total) =>
                    {
                        createBranchesProgressMessage = $"Created {completed} of {total} branches";
                        InvokeAsync(StateHasChanged);
                    },
                    repositoryIds: EffectiveActionRepositoryIds,
                    cancellationToken: _createBranchesCts.Token);
            }
            await RefreshFromSync();
        }
        catch (OperationCanceledException)
        {
            await ReloadWorkspaceDataAfterCancelAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating branches for workspace {WorkspaceId}", WorkspaceId);
            errorMessage = "Create branches failed. The GrayMoon Agent may be offline. Start the Agent and try again.";
        }
        finally
        {
            isCreatingBranches = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task OnBranchChangedAsync()
    {
        // Refresh workspace data to show updated branch
        await RefreshFromSync();
    }

    private async Task CreateSingleBranchAsync((int RepositoryId, string? RepositoryName, string NewBranchName, string BaseBranch, bool SetUpstream) request)
    {
        var (repositoryId, repositoryName, newBranchName, baseBranch, setUpstream) = request;
        if (workspace == null || isCreatingBranch || isSyncing || isUpdating)
            return;

        CloseSwitchBranchModal();
        isCreatingBranch = true;
        createBranchMessage = $"Creating {newBranchName} for {repositoryName ?? "repository"}...";
        errorMessage = null;
        await InvokeAsync(StateHasChanged);

        try
        {
            var httpClient = HttpClientFactory.CreateClient();
            var apiRequest = new
            {
                workspaceId = WorkspaceId,
                repositoryId,
                newBranchName,
                baseBranch
            };
            var json = System.Text.Json.JsonSerializer.Serialize(apiRequest);
            var content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");
            var baseUrl = NavigationManager.BaseUri.TrimEnd('/');
            var response = await httpClient.PostAsync($"{baseUrl}/api/branches/create", content);

            if (response.IsSuccessStatusCode)
            {
                var responseContent = await response.Content.ReadAsStringAsync();
                var result = System.Text.Json.JsonSerializer.Deserialize<CreateBranchApiResult>(responseContent, new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                if (result != null && result.Success)
                {
                    if (setUpstream)
                    {
                        var upstreamRequest = new
                        {
                            workspaceId = WorkspaceId,
                            repositoryId,
                            branchName = newBranchName
                        };
                        var upstreamJson = System.Text.Json.JsonSerializer.Serialize(upstreamRequest);
                        var upstreamContent = new System.Net.Http.StringContent(upstreamJson, System.Text.Encoding.UTF8, "application/json");
                        var upstreamResponse = await httpClient.PostAsync($"{baseUrl}/api/branches/set-upstream", upstreamContent);
                        if (upstreamResponse.IsSuccessStatusCode)
                        {
                            var upstreamResponseContent = await upstreamResponse.Content.ReadAsStringAsync();
                            var upstreamResult = System.Text.Json.JsonSerializer.Deserialize<CreateBranchApiResult>(upstreamResponseContent, new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                            if (upstreamResult != null && !upstreamResult.Success)
                                errorMessage = upstreamResult.Error ?? "Branch created but failed to set upstream.";
                        }
                        else
                            errorMessage = "Branch created but failed to set upstream.";
                    }
                    await RefreshFromSync();
                }
                else
                {
                    errorMessage = result?.Error ?? "Failed to create branch.";
                }
            }
            else
            {
                var errorText = await response.Content.ReadAsStringAsync();
                errorMessage = $"Failed to create branch: {response.StatusCode}";
                Logger.LogError("CreateBranch failed: {StatusCode}, {Error}", response.StatusCode, errorText);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating branch for repository {RepositoryId}", repositoryId);
            errorMessage = "An error occurred while creating branch.";
        }
        finally
        {
            isCreatingBranch = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SyncToDefaultFromModalAsync((int RepositoryId, string? RepositoryName, string CurrentBranchName, string DefaultBranch) request)
    {
        var (repositoryId, repositoryName, currentBranchName, defaultBranch) = request;
        if (workspace == null || isSyncingToDefault || isSyncing || isUpdating)
            return;

        CloseSwitchBranchModal();
        isSyncingToDefault = true;
        syncToDefaultMessage = $"Syncing to {defaultBranch} for {repositoryName ?? "repository"}...";
        errorMessage = null;
        await InvokeAsync(StateHasChanged);

        try
        {
            var httpClient = HttpClientFactory.CreateClient();
            var apiRequest = new
            {
                workspaceId = WorkspaceId,
                repositoryId,
                currentBranchName
            };
            var json = System.Text.Json.JsonSerializer.Serialize(apiRequest);
            var content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");
            var baseUrl = NavigationManager.BaseUri.TrimEnd('/');
            var response = await httpClient.PostAsync($"{baseUrl}/api/branches/sync-to-default", content);

            if (response.IsSuccessStatusCode)
            {
                await RefreshFromSync();
            }
            else
            {
                var errorText = await response.Content.ReadAsStringAsync();
                errorMessage = $"Failed to sync to default branch: {response.StatusCode}";
                Logger.LogError("SyncToDefault failed: {StatusCode}, {Error}", response.StatusCode, errorText);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error syncing to default branch for repository {RepositoryId}", repositoryId);
            errorMessage = "An error occurred while syncing to default branch.";
        }
        finally
        {
            isSyncingToDefault = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task CheckoutBranchAsync((int RepositoryId, string BranchName) request)
    {
        var (repositoryId, branchName) = request;
        if (workspace == null || isCheckingOut || isSyncing || isUpdating || isCommitSyncing)
            return;

        _checkoutCts?.Cancel();
        _checkoutCts?.Dispose();
        _checkoutCts = new CancellationTokenSource();

        isCheckingOut = true;
        
        // Get repository name for display
        var repo = workspaceRepositories.FirstOrDefault(wr => wr.RepositoryId == repositoryId)?.Repository;
        var repoName = repo?.RepositoryName ?? "repository";
        checkoutProgressMessage = $"Checking out {branchName} for {repoName}...";
        
        errorMessage = null;
        try
        {
            StateHasChanged();
            await Task.Yield();

            var httpClient = HttpClientFactory.CreateClient();
            var apiRequest = new
            {
                repositoryId,
                workspaceId = WorkspaceId,
                branchName
            };
            var json = System.Text.Json.JsonSerializer.Serialize(apiRequest);
            var content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");
            
            var baseUrl = NavigationManager.BaseUri.TrimEnd('/');
            var response = await httpClient.PostAsync($"{baseUrl}/api/branches/checkout", content, _checkoutCts.Token);
            
            if (response.IsSuccessStatusCode)
            {
                var responseContent = await response.Content.ReadAsStringAsync(_checkoutCts.Token);
                var result = System.Text.Json.JsonSerializer.Deserialize<CheckoutBranchResponse>(responseContent, AgentResponseJson.Options);

                if (result != null && !result.Success)
                {
                    repositoryErrors[repositoryId] = !string.IsNullOrWhiteSpace(result.ErrorMessage) ? result.ErrorMessage : "Failed to checkout branch.";
                    checkoutProgressMessage = "Checkout completed with errors.";
                    await Task.Delay(2000, _checkoutCts.Token);
                }
                else
                {
                    repositoryErrors.Remove(repositoryId);
                    checkoutProgressMessage = "Checkout completed successfully.";
                    await Task.Delay(1000, _checkoutCts.Token);
                }
            }
            else
            {
                var errorText = await response.Content.ReadAsStringAsync(_checkoutCts.Token);
                repositoryErrors[repositoryId] = $"Failed to checkout branch: {response.StatusCode}";
                Logger.LogError("Checkout failed: {StatusCode}, {Error}", response.StatusCode, errorText);
            }

            // Refresh workspace data to show updated branch (same as CommitSyncAsync)
            await RefreshFromSync();
        }
        catch (OperationCanceledException)
        {
            // Operation was cancelled
            await ReloadWorkspaceDataAfterCancelAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error checking out branch for repository {RepositoryId}", repositoryId);
            repositoryErrors[repositoryId] = "Failed to checkout branch. The GrayMoon Agent may be offline. Start the Agent and try again.";
        }
        finally
        {
            isCheckingOut = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void AbortCheckoutAsync()
    {
        _checkoutCts?.Cancel();
    }

    private void DismissRepositoryError(int repositoryId)
    {
        repositoryErrors.Remove(repositoryId);
        StateHasChanged();
    }

    private string? GetRepositoryUrl(Repository repo)
    {
        if (string.IsNullOrEmpty(repo.CloneUrl))
            return null;

        // Convert git clone URL to GitHub web URL
        // Examples:
        // https://github.com/org/repo.git -> https://github.com/org/repo
        // git@github.com:org/repo.git -> https://github.com/org/repo
        // https://github.com/org/repo -> https://github.com/org/repo (already correct)
        
        var url = repo.CloneUrl.Trim();
        
        // Handle SSH format: git@github.com:org/repo.git
        if (url.StartsWith("git@github.com:", StringComparison.OrdinalIgnoreCase))
        {
            url = url.Replace("git@github.com:", "https://github.com/", StringComparison.OrdinalIgnoreCase);
        }
        // Handle HTTPS format: https://github.com/org/repo.git
        else if (url.StartsWith("https://github.com/", StringComparison.OrdinalIgnoreCase) || 
                 url.StartsWith("http://github.com/", StringComparison.OrdinalIgnoreCase))
        {
            // Already HTTPS/HTTP, just need to remove .git if present
        }
        else
        {
            // Unknown format, return null
            return null;
        }
        
        // Remove .git suffix if present
        if (url.EndsWith(".git", StringComparison.OrdinalIgnoreCase))
        {
            url = url.Substring(0, url.Length - 4);
        }
        
        return url;
    }

    private async Task CopyVersionToClipboard(string version)
    {
        if (!string.IsNullOrEmpty(version))
        {
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", version);
            ToastService.Show($"{version} copied to the clipboard");
            
            // Hide highlight after click (like a button)
            clickedVersions.Add(version);
            StateHasChanged();
        }
    }

    private void OnVersionMouseLeave(string? version)
    {
        if (!string.IsNullOrEmpty(version))
        {
            // Clear clicked state when mouse leaves, allowing hover to work again
            clickedVersions.Remove(version);
            StateHasChanged();
        }
    }

    private string GetDependencyGraphUrl(int repositoryId)
    {
        return $"/workspaces/{WorkspaceId}/dependencies?repo={repositoryId}";
    }

    private string GetDependencyGraphUrlForLevel(int level)
    {
        return $"/workspaces/{WorkspaceId}/dependencies?level={level}";
    }

    private static string GetSyncBadgeText(RepoSyncStatus status)
    {
        return status switch
        {
            RepoSyncStatus.InSync => "in sync",
            RepoSyncStatus.NeedsSync => "sync",
            RepoSyncStatus.NotCloned => "not cloned",
            RepoSyncStatus.VersionMismatch => "version",
            RepoSyncStatus.Error => "error",
            _ => "sync"
        };
    }

    private async Task LoadGridSelectionFromStorageAsync()
    {
        try
        {
            var key = StorageKeyPrefix + WorkspaceId + StorageKeySuffix;
            var json = await JSRuntime.InvokeAsync<string?>("graymoonStorageGet", key);
            if (string.IsNullOrWhiteSpace(json))
            {
                gridSelectedRepositoryIds = new HashSet<int>();
            }
            else
            {
                var list = System.Text.Json.JsonSerializer.Deserialize<List<int>>(json);
                gridSelectedRepositoryIds = list != null ? list.ToHashSet() : new HashSet<int>();
            }

            var showSelectionKey = StorageKeyPrefix + WorkspaceId + StorageKeyShowSelectionSuffix;
            var showSelectionValue = await JSRuntime.InvokeAsync<string?>("graymoonStorageGet", showSelectionKey);
            if (string.Equals(showSelectionValue, "true", StringComparison.OrdinalIgnoreCase))
                showSelectionColumn = true;
            else if (string.Equals(showSelectionValue, "false", StringComparison.OrdinalIgnoreCase))
                showSelectionColumn = false;
            else if (gridSelectedRepositoryIds.Count > 0)
                showSelectionColumn = true;
        }
        catch
        {
            gridSelectedRepositoryIds = new HashSet<int>();
        }
        finally
        {
            _selectionStateLoaded = true;
        }
    }

    private async Task PersistGridSelectionAsync()
    {
        try
        {
            var key = StorageKeyPrefix + WorkspaceId + StorageKeySuffix;
            var json = System.Text.Json.JsonSerializer.Serialize(gridSelectedRepositoryIds.ToList());
            await JSRuntime.InvokeVoidAsync("graymoonStorageSet", key, json);
        }
        catch
        {
            // ignore
        }
    }

    private async Task ToggleSelectionModeAsync()
    {
        showSelectionColumn = !showSelectionColumn;
        await PersistShowSelectionAsync();
        StateHasChanged();
    }

    private async Task OnSelectionModeKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" || e.Key == " ")
        {
            await ToggleSelectionModeAsync();
        }
    }

    private async Task PersistShowSelectionAsync()
    {
        try
        {
            var key = StorageKeyPrefix + WorkspaceId + StorageKeyShowSelectionSuffix;
            await JSRuntime.InvokeVoidAsync("graymoonStorageSet", key, showSelectionColumn ? "true" : "false");
        }
        catch
        {
            // ignore
        }
    }

    private async Task ToggleSelectAllFilteredAsync(ChangeEventArgs e)
    {
        var checked_ = e.Value as bool? ?? false;
        var filteredIds = FilteredWorkspaceRepositories.Select(wr => wr.RepositoryId).ToHashSet();
        if (checked_)
            foreach (var id in filteredIds)
                gridSelectedRepositoryIds.Add(id);
        else
            gridSelectedRepositoryIds.RemoveWhere(filteredIds.Contains);
        await PersistGridSelectionAsync();
        StateHasChanged();
    }

    private async Task ToggleRepositorySelection(int repositoryId)
    {
        if (gridSelectedRepositoryIds.Contains(repositoryId))
            gridSelectedRepositoryIds.Remove(repositoryId);
        else
            gridSelectedRepositoryIds.Add(repositoryId);
        await PersistGridSelectionAsync();
        StateHasChanged();
    }

    private void OnSearchKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Escape")
        {
            searchTerm = string.Empty;
            StateHasChanged();
        }
    }

    private List<WorkspaceRepositoryLink> GetFilteredWorkspaceRepositories()
    {
        var words = searchTerm
            .Split(' ', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
            .Select(w => w.Trim())
            .Where(w => w.Length > 0)
            .ToList();

        if (words.Count == 0)
            return workspaceRepositories;

        return workspaceRepositories.Where(wr =>
        {
            var repoName = wr.Repository?.RepositoryName ?? string.Empty;
            var branchName = wr.BranchName ?? string.Empty;
            var version = wr.GitVersion ?? string.Empty;
            var levelTitle = wr.DependencyLevel == null ? "No dependencies" : $"Level {wr.DependencyLevel}";
            var syncText = GetSyncBadgeText(repoSyncStatus.TryGetValue(wr.RepositoryId, out var s) ? s : RepoSyncStatus.NeedsSync);
            var searchable = $"{repoName} {branchName} {version} {levelTitle} {syncText}";
            return words.All(word => searchable.Contains(word, StringComparison.OrdinalIgnoreCase));
        }).ToList();
    }

    /// <summary>Try to extract a user-facing error message from an API response body (JSON or plain text).</summary>
    private static string? TryGetErrorMessageFromResponseBody(string? body)
    {
        if (string.IsNullOrWhiteSpace(body))
            return null;
        var trimmed = body.Trim();
        if (trimmed.Length == 0)
            return null;
        try
        {
            using var doc = System.Text.Json.JsonDocument.Parse(trimmed);
            var root = doc.RootElement;
            if (root.TryGetProperty("errorMessage", out var em) && em.ValueKind == System.Text.Json.JsonValueKind.String)
                return em.GetString();
            if (root.TryGetProperty("detail", out var d) && d.ValueKind == System.Text.Json.JsonValueKind.String)
                return d.GetString();
            if (root.TryGetProperty("title", out var t) && t.ValueKind == System.Text.Json.JsonValueKind.String)
                return t.GetString();
        }
        catch
        {
            // Not JSON or invalid
        }
        return trimmed.Length > 500 ? trimmed.Substring(0, 500) + "…" : trimmed;
    }

    private sealed class CreateBranchApiResult
    {
        public bool Success { get; set; }
        public string? Error { get; set; }
    }
}
