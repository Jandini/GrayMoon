@page "/workspaces/{WorkspaceId:int}"
@rendermode @(new InteractiveServerRenderMode(prerender: false))
@implements IDisposable
@using GrayMoon.App.Models
@using GrayMoon.App.Repositories
@using GrayMoon.App.Services
@using GrayMoon.App.Components.Shared
@using GrayMoon.App.Components.Modals
@using Microsoft.AspNetCore.SignalR.Client
@inject WorkspaceRepository WorkspaceRepository
@inject WorkspaceGitService WorkspaceGitService
@inject GitHubConnectorRepository ConnectorRepository
@inject GitHubRepositoryService RepositoryService
@inject NavigationManager NavigationManager
@inject ILogger<WorkspaceRepositories> Logger
@using WorkspaceModel = GrayMoon.App.Models.Workspace

<PageTitle>@(workspace?.Name ?? "Workspace")</PageTitle>

<div class="container-fluid page-container grid-page">
    <div class="grid-page-header">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <div>
                <h2>@(workspace?.Name ?? "Workspace")</h2>
                <p class="text-muted mb-0" style="min-height: 1.5rem;">
                    @if (workspaceRepositories.Count > 0)
                    {
                        @($"{workspaceRepositories.Count} {(workspaceRepositories.Count == 1 ? "repository" : "repositories")}")
                    }
                    &nbsp;
                </p>
            </div>
            <div class="d-flex gap-2">
                <button class="btn btn-secondary"
                        @onclick="ShowRepositoriesModalAsync"
                        disabled="@(workspace == null)">
                    Repositories
                </button>
                <button class="btn @(isOutOfSync == true ? "btn-danger" : "btn-primary")"
                        @onclick="SyncAsync"
                        disabled="@(isSyncing || workspaceRepositories.Count == 0)">
                    Sync
                </button>
            </div>
        </div>
        @if (errorMessage != null)
        {
            <div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i> @errorMessage
            </div>
        }
    </div>
    @if (errorMessage == null)
    {
        <div class="grid-page-body">
            <div class="card page-card mb-4">
                <div class="card-body p-0">
                    <div class="table-responsive">
                        <table class="table table-striped table-hover mb-0 repositories-table">
                        <thead class="table-dark">
                            <tr>
                                <th class="col-repo">Repository</th>
                                <th class="col-version">Version</th>
                                <th class="col-branch">Branch</th>
                                <th class="col-projects">Projects</th>
                                <th class="col-sync">Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            @if (isLoading)
                            {
                                <tr>
                                    <td colspan="5" class="text-center text-muted py-4">
                                        Loading workspace...
                                    </td>
                                </tr>
                            }
                            else if (workspaceRepositories.Count == 0)
                            {
                                <tr>
                                    <td colspan="5" class="text-center text-muted py-4">
                                        No repositories assigned to this workspace.
                                    </td>
                                </tr>
                            }
                            else
                            {
                                @foreach (var wr in workspaceRepositories)
                                {
                                    var repo = wr.GitHubRepository;
                                    @if (repo != null)
                                    {
                                        <tr>
                                            <td class="col-repo"><strong>@repo.RepositoryName</strong></td>
                                            <td class="col-version text-muted">@(wr.GitVersion ?? "-")</td>
                                            <td class="col-branch text-muted">@(wr.BranchName ?? "-")</td>
                                            <td class="col-projects text-muted">@((repo.ProjectCount ?? wr.Projects)?.ToString() ?? "-")</td>
                                            <td class="col-sync">@GetRepoSyncBadge(repo.GitHubRepositoryId)</td>
                                        </tr>
                                    }
                                }
                            }
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        </div>
    }
</div>

<WorkspaceRepositoriesModal IsVisible="@showRepositoriesModal"
                            Title="@($"Repositories for {workspace?.Name ?? "Workspace"}")"
                            Repositories="@repositoriesModalRepositories"
                            SelectedRepositoryIds="@selectedRepositoryIds"
                            HasConnectors="@hasConnectors"
                            IsSaving="@isSavingRepositories"
                            IsFetching="@isPersisting"
                            ErrorMessage="@repositoriesModalErrorMessage"
                            OnSave="@SaveRepositoriesAsync"
                            OnCancel="@CloseRepositoriesModal"
                            OnFetchRepositories="@FetchRepositoriesAsync" />

<LoadingOverlay IsVisible="@isLoading" Message="Loading workspace..." />
<LoadingOverlay IsVisible="@isSyncing" Message="@syncProgressMessage" OnAbort="AbortSyncAsync" />
<LoadingOverlay IsVisible="@(showRepositoriesModal && isPersisting)" Message="@(fetchedRepositoryCount is null || fetchedRepositoryCount == 0 ? "Fetching repositories..." : $"Fetched {fetchedRepositoryCount} {(fetchedRepositoryCount == 1 ? "repository" : "repositories")}...")" OnAbort="AbortFetchRepositories" />

@code {
    [Parameter] public int WorkspaceId { get; set; }

    private WorkspaceModel? workspace;
    private List<WorkspaceRepositoryLink> workspaceRepositories = new();
    private IReadOnlyDictionary<int, RepoGitVersionInfo> repoGitInfos = new Dictionary<int, RepoGitVersionInfo>();
    private string? errorMessage;
    private bool isLoading = true;
    private bool isSyncing = false;
    private string syncProgressMessage = "Synchronizing...";
    private bool? isOutOfSync = null;
    private Dictionary<int, RepoSyncStatus> repoSyncStatus = new();
    private CancellationTokenSource? _syncCts;
    private HubConnection? _hubConnection;
    private bool showRepositoriesModal;
    private bool isSavingRepositories;
    private bool isPersisting;
    private bool hasConnectors;
    private string? repositoriesModalErrorMessage;
    private List<GitHubRepositoryEntry>? repositoriesModalRepositories;
    private HashSet<int> selectedRepositoryIds = new();
    private int? fetchedRepositoryCount;
    private CancellationTokenSource? _fetchRepositoriesCts;

    protected override async Task OnInitializedAsync()
    {
        await LoadWorkspaceAsync();
        ApplySyncStateFromWorkspace();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && workspace != null && errorMessage == null)
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/hubs/workspace-sync"))
                .WithAutomaticReconnect()
                .Build();
            _hubConnection.On<int>("WorkspaceSynced", async (workspaceId) =>
            {
                if (workspaceId == WorkspaceId)
                    await InvokeAsync(RefreshFromSync);
            });
            await _hubConnection.StartAsync();
        }
    }

    private void ApplySyncStateFromWorkspace()
    {
        if (workspace == null || workspaceRepositories.Count == 0)
        {
            return;
        }
        repoSyncStatus = workspaceRepositories
            .Where(wr => wr.GitHubRepository != null)
            .ToDictionary(wr => wr.GitHubRepositoryId, wr => wr.SyncStatus);
        isOutOfSync = repoSyncStatus.Values.Any(s => s != RepoSyncStatus.InSync);
        StateHasChanged();
    }

    public void Dispose()
    {
        _ = _hubConnection?.StopAsync();
        _hubConnection?.DisposeAsync();
        _syncCts?.Cancel();
        _syncCts?.Dispose();
        _fetchRepositoriesCts?.Cancel();
        _fetchRepositoriesCts?.Dispose();
    }

    private async Task RefreshFromSync()
    {
        if (isSyncing)
            return;
        await ReloadWorkspaceDataAsync();
        ApplySyncStateFromWorkspace();
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadWorkspaceAsync()
    {
        try
        {
            isLoading = true;
            errorMessage = null;
            await ReloadWorkspaceDataAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading workspace {WorkspaceId}", WorkspaceId);
            errorMessage = "Failed to load workspace. Please try again later.";
            workspaceRepositories = new List<WorkspaceRepositoryLink>();
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task ReloadWorkspaceDataAsync()
    {
        workspace = await WorkspaceRepository.GetByIdAsync(WorkspaceId);
        if (workspace == null)
        {
            errorMessage = "Workspace not found.";
            workspaceRepositories = new List<WorkspaceRepositoryLink>();
            return;
        }

        workspaceRepositories = workspace.Repositories
            .OrderBy(wr => wr.GitHubRepository?.RepositoryName)
            .ToList();
    }

    private RenderFragment GetRepoSyncBadge(int repositoryId) => builder =>
    {
        if (repoSyncStatus.TryGetValue(repositoryId, out var status))
        {
            var (text, bgColor) = status switch
            {
                RepoSyncStatus.InSync => ("in sync", "#198754"),
                RepoSyncStatus.NeedsSync => ("sync", "#dc3545"),
                RepoSyncStatus.NotCloned => ("not cloned", "#6c757d"),
                RepoSyncStatus.VersionMismatch => ("version", "#dc3545"),
                RepoSyncStatus.Error => ("error", "#dc3545"),
                _ => ("sync", "#6c757d")
            };
            builder.OpenElement(0, "span");
            builder.AddAttribute(1, "class", "badge");
            builder.AddAttribute(2, "style", $"background-color: {bgColor}; color: #fff;");
            builder.AddContent(3, text);
            builder.CloseElement();
        }
    };

    private void AbortSyncAsync()
    {
        _syncCts?.Cancel();
    }

    private async Task ShowRepositoriesModalAsync()
    {
        if (workspace == null)
        {
            return;
        }
        repositoriesModalErrorMessage = null;
        selectedRepositoryIds = workspace.Repositories
            .Select(link => link.GitHubRepositoryId)
            .ToHashSet();
        await EnsureRepositoriesForModalAsync();
        showRepositoriesModal = true;
    }

    private async Task EnsureRepositoriesForModalAsync()
    {
        var connectors = await ConnectorRepository.GetAllAsync();
        hasConnectors = connectors.Count > 0;
        if (repositoriesModalRepositories == null && hasConnectors)
        {
            repositoriesModalRepositories = await RepositoryService.GetPersistedRepositoriesAsync();
        }
    }

    private void CloseRepositoriesModal()
    {
        showRepositoriesModal = false;
        repositoriesModalErrorMessage = null;
    }

    private async Task SaveRepositoriesAsync()
    {
        if (workspace == null || isSavingRepositories)
        {
            return;
        }
        if (selectedRepositoryIds.Count == 0)
        {
            repositoriesModalErrorMessage = "Select at least one repository.";
            return;
        }
        isSavingRepositories = true;
        repositoriesModalErrorMessage = null;
        await InvokeAsync(StateHasChanged);
        try
        {
            await WorkspaceRepository.UpdateAsync(WorkspaceId, workspace.Name, selectedRepositoryIds);
            CloseRepositoriesModal();
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving repositories for workspace {WorkspaceId}", WorkspaceId);
            repositoriesModalErrorMessage = ex.Message;
        }
        finally
        {
            isSavingRepositories = false;
        }
    }

    private void AbortFetchRepositories()
    {
        _fetchRepositoriesCts?.Cancel();
    }

    private async Task FetchRepositoriesAsync()
    {
        if (!hasConnectors || isPersisting)
        {
            return;
        }
        _fetchRepositoriesCts?.Cancel();
        _fetchRepositoriesCts = new CancellationTokenSource();
        try
        {
            isPersisting = true;
            fetchedRepositoryCount = null;
            repositoriesModalErrorMessage = null;
            await InvokeAsync(StateHasChanged);
            var progress = new Progress<int>(count =>
            {
                fetchedRepositoryCount = count;
                _ = InvokeAsync(StateHasChanged);
            });
            var result = await RepositoryService.RefreshRepositoriesAsync(progress, _fetchRepositoriesCts.Token);
            repositoriesModalRepositories = result.Repositories.ToList();
        }
        catch (OperationCanceledException)
        {
            repositoriesModalRepositories = await RepositoryService.GetPersistedRepositoriesAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error fetching repositories");
            repositoriesModalErrorMessage = "Failed to fetch repositories. Please try again later.";
            repositoriesModalRepositories = new List<GitHubRepositoryEntry>();
        }
        finally
        {
            isPersisting = false;
        }
    }

    private async Task SyncAsync()
    {
        if (workspace == null || workspaceRepositories.Count == 0 || isSyncing)
        {
            return;
        }

        _syncCts?.Cancel();
        _syncCts = new CancellationTokenSource();

        isSyncing = true;
        syncProgressMessage = "Synchronizing...";
        errorMessage = null;
        StateHasChanged();
        await Task.Yield();

        try
        {
            var results = await WorkspaceGitService.SyncAsync(
                WorkspaceId,
                onProgress: (completed, total, repoId, info) =>
                {
                    syncProgressMessage = $"Synchronized {completed} of {total}";
                    repoSyncStatus[repoId] = (info.Version == "-" && info.Branch == "-")
                        ? RepoSyncStatus.Error
                        : RepoSyncStatus.InSync;

                    var wr = workspaceRepositories.FirstOrDefault(w => w.GitHubRepositoryId == repoId);
                    if (wr != null)
                    {
                        wr.GitVersion = info.Version == "-" ? null : info.Version;
                        wr.BranchName = info.Branch == "-" ? null : info.Branch;
                        wr.Projects = info.Projects;
                    }

                    InvokeAsync(StateHasChanged);
                },
                cancellationToken: _syncCts.Token);
            repoGitInfos = results;

            isOutOfSync = repoSyncStatus.Values.Any(v => v != RepoSyncStatus.InSync);
        }
        catch (OperationCanceledException)
        {
            // Sync was cancelled - reload workspace to restore pre-sync data (onProgress may have partially updated in-memory state)
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error syncing workspace {WorkspaceId}", WorkspaceId);
            errorMessage = "Failed to sync. Please try again later.";
        }
        finally
        {
            isSyncing = false;
        }
    }
}
