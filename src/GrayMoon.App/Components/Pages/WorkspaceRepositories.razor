@page "/workspaces/{WorkspaceId:int}"
@rendermode @(new InteractiveServerRenderMode(prerender: false))
@implements IDisposable
@using GrayMoon.App.Models
@using GrayMoon.App.Repositories
@using GrayMoon.App.Services
@using GrayMoon.App.Components.Shared
@using GrayMoon.App.Components.Modals
@using Microsoft.AspNetCore.SignalR.Client
@using System.Text.Json
@inject WorkspaceRepository WorkspaceRepository
@inject WorkspaceGitService WorkspaceGitService
@inject IServiceScopeFactory ServiceScopeFactory
@inject ConnectorRepository ConnectorRepository
@inject GitHubRepositoryService RepositoryService
@inject NavigationManager NavigationManager
@inject ILogger<WorkspaceRepositories> Logger
@inject IHttpClientFactory HttpClientFactory
@using WorkspaceModel = GrayMoon.App.Models.Workspace

<PageTitle>@(workspace?.Name ?? "Workspace")</PageTitle>

<div class="container-fluid page-container grid-page">
    <div class="grid-page-header">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <div>
                <h2>@(workspace?.Name ?? "Workspace")</h2>
                <p class="text-muted mb-0" style="min-height: 1.5rem;">
                    @if (workspaceRepositories.Count > 0)
                    {
                        <span class="repositories-count-link" @onclick="ShowRepositoriesModalAsync" @onclick:preventDefault>
                            @($"{workspaceRepositories.Count} {(workspaceRepositories.Count == 1 ? "repository" : "repositories")}")
                        </span>
                    }
                    else if (workspace != null)
                    {
                        <span class="repositories-count-link" @onclick="ShowRepositoriesModalAsync" @onclick:preventDefault>0 repositories</span>
                    }
                    else
                    {
                        <span>&nbsp;</span>
                    }
                </p>
            </div>
            <div class="d-flex gap-2">
                <button class="btn @(hasUnmatchedDependencies ? "btn-danger" : "btn-secondary")"
                        @onclick="UpdateDependenciesAsync"
                        disabled="@(workspace == null || workspaceRepositories.Count == 0 || isSyncing || isUpdating)">
                    Update
                </button>
                <button class="btn @(isOutOfSync == true ? "btn-danger" : "btn-primary")"
                        @onclick="SyncAsync"
                        disabled="@(isSyncing || isUpdating || workspaceRepositories.Count == 0)">
                    Sync
                </button>
            </div>
        </div>
        @if (errorMessage != null)
        {
            <div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i> @errorMessage
            </div>
        }
    </div>
    @if (errorMessage == null)
    {
        <div class="grid-page-body">
            <div class="card page-card mb-4">
                <div class="card-body p-0">
                    <div class="table-responsive">
                        <table class="table table-striped table-hover mb-0 repositories-table resizable-columns">
                        <thead class="table-dark">
                            <tr>
                                <th class="col-repo">Repository</th>
                                <th class="col-version">Version</th>
                                <th class="col-branch">Branch</th>
                                <th class="col-deps">Dependencies</th>
                                <th class="col-commits">Commits</th>
                                <th class="col-sync col-status-badge">Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            @if (isLoading)
                            {
                                <tr>
                                    <td colspan="6" class="text-center text-muted py-4">
                                        Loading workspace...
                                    </td>
                                </tr>
                            }
                            else if (workspaceRepositories.Count == 0)
                            {
                                <tr>
                                    <td colspan="6" class="text-center text-muted py-4">
                                        No repositories assigned to this workspace.
                                    </td>
                                </tr>
                            }
                            else
                            {
                                @foreach (var wr in workspaceRepositories)
                                {
                                    var repo = wr.Repository;
                                    @if (repo != null)
                                    {
                                        var repoUrl = GetRepositoryUrl(repo);
                                        var branchUrl = !string.IsNullOrEmpty(repoUrl) && !string.IsNullOrEmpty(wr.BranchName)
                                            ? $"{repoUrl}/compare/main...{Uri.EscapeDataString(wr.BranchName)}"
                                            : null;
                                        <tr>
                                            <td class="col-repo">
                                                @if (!string.IsNullOrEmpty(repoUrl))
                                                {
                                                    <a href="@repoUrl" target="_blank" rel="noopener noreferrer" class="repo-link">
                                                        <strong>@repo.RepositoryName</strong>
                                                    </a>
                                                }
                                                else
                                                {
                                                    <strong>@repo.RepositoryName</strong>
                                                }
                                            </td>
                                            <td class="col-version text-muted">@(wr.GitVersion ?? "-")</td>
                                            <td class="col-branch">
                                                <span class="branch-text branch-clickable" 
                                                      style="cursor: pointer;"
                                                      @onclick='() => ShowSwitchBranchModal(repo.RepositoryId, wr.BranchName, repo.CloneUrl)'
                                                      title="Click to switch branch">
                                                    @(wr.BranchName ?? "-")
                                                </span>
                                            </td>
                                            <td class="col-deps col-status-badge">
                                                @{
                                                    var depCount = wr.Dependencies ?? 0;
                                                    var unmatchedDeps = wr.UnmatchedDeps ?? 0;
                                                }
                                                @if (depCount == 0)
                                                {
                                                    <span class="badge build-dep-badge build-dep-badge-none">0</span>
                                                }
                                                else if (unmatchedDeps == 0)
                                                {
                                                    <span class="badge build-dep-badge build-dep-badge-ok">@depCount</span>
                                                }
                                                else
                                                {
                                                    <span class="badge build-dep-badge build-dep-badge-mismatch">@unmatchedDeps of @depCount</span>
                                                }
                                            </td>
                                            <td class="col-commits">@GetCommitsBadge(repo.RepositoryId, wr.OutgoingCommits, wr.IncomingCommits)</td>
                                            <td class="col-sync col-status-badge">@GetRepoSyncBadge(repo.RepositoryId)</td>
                                        </tr>
                                        @if (repositoryErrors.TryGetValue(repo.RepositoryId, out var repoError))
                                        {
                                            <tr class="repo-error-row">
                                                <td colspan="6" class="p-0">
                                                    <div class="alert alert-danger alert-dismissible mb-0 rounded-0" role="alert">
                                                        <div class="d-flex align-items-start">
                                                            <div class="flex-grow-1" style="white-space: pre-wrap; word-wrap: break-word;">
                                                                <strong>Error:</strong> @repoError
                                                            </div>
                                                            <button type="button" 
                                                                    class="btn-close ms-2" 
                                                                    aria-label="Close"
                                                                    @onclick='() => DismissRepositoryError(repo.RepositoryId)'></button>
                                                        </div>
                                                    </div>
                                                </td>
                                            </tr>
                                        }
                                    }
                                }
                            }
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        </div>
    }
</div>

<WorkspaceRepositoriesModal IsVisible="@showRepositoriesModal"
                            Title="@($"Repositories for {workspace?.Name ?? "Workspace"}")"
                            Repositories="@repositoriesModalRepositories"
                            SelectedRepositoryIds="@selectedRepositoryIds"
                            HasConnectors="@hasConnectors"
                            IsSaving="@isSavingRepositories"
                            IsFetching="@isPersisting"
                            ErrorMessage="@repositoriesModalErrorMessage"
                            OnSave="@SaveRepositoriesAsync"
                            OnCancel="@CloseRepositoriesModal"
                            OnFetchRepositories="@FetchRepositoriesAsync" />

<SwitchBranchModal IsVisible="@showSwitchBranchModal"
                   WorkspaceId="@WorkspaceId"
                   RepositoryId="@switchBranchRepositoryId"
                   RepositoryName="@switchBranchRepositoryName"
                   CurrentBranch="@switchBranchCurrentBranch"
                   RepositoryUrl="@switchBranchRepositoryUrl"
                   OnCancel="@CloseSwitchBranchModal"
                   OnBranchChanged="@OnBranchChangedAsync"
                   OnCheckoutBranch="@CheckoutBranchAsync" />

<LoadingOverlay IsVisible="@isLoading" Message="Loading workspace..." />
<LoadingOverlay IsVisible="@isSyncing" Message="@syncProgressMessage" OnAbort="AbortSyncAsync" />
<LoadingOverlay IsVisible="@isUpdating" Message="@updateProgressMessage" OnAbort="AbortUpdateAsync" />
<LoadingOverlay IsVisible="@isPullPushing" Message="@pullPushProgressMessage" OnAbort="AbortPullPushAsync" />
<LoadingOverlay IsVisible="@isCheckingOut" Message="@checkoutProgressMessage" OnAbort="AbortCheckoutAsync" />
<LoadingOverlay IsVisible="@(showRepositoriesModal && isPersisting)" Message="@(fetchedRepositoryCount is null || fetchedRepositoryCount == 0 ? "Fetching repositories..." : $"Fetched {fetchedRepositoryCount} {(fetchedRepositoryCount == 1 ? "repository" : "repositories")}...")" OnAbort="AbortFetchRepositories" />

@code {
    [Parameter] public int WorkspaceId { get; set; }

    private WorkspaceModel? workspace;
    private List<WorkspaceRepositoryLink> workspaceRepositories = new();
    private IReadOnlyDictionary<int, RepoGitVersionInfo> repoGitInfos = new Dictionary<int, RepoGitVersionInfo>();
    private string? errorMessage;
    private bool isLoading = true;
    private bool isSyncing = false;
    private string syncProgressMessage = "Synchronizing...";
    private bool isUpdating = false;
    private string updateProgressMessage = "Updating dependencies...";
    private CancellationTokenSource? _updateCts;
    private bool? isOutOfSync = null;
    private bool hasUnmatchedDependencies => workspaceRepositories.Any(wr => (wr.UnmatchedDeps ?? 0) > 0);
    private Dictionary<int, RepoSyncStatus> repoSyncStatus = new();
    private CancellationTokenSource? _syncCts;
    private bool isPullPushing = false;
    private string pullPushProgressMessage = "Synchronizing commits...";
    private CancellationTokenSource? _pullPushCts;
    private bool isCheckingOut = false;
    private string checkoutProgressMessage = "Checking out branch...";
    private CancellationTokenSource? _checkoutCts;
    private Dictionary<int, string> repositoryErrors = new(); // repositoryId -> error message
    private HubConnection? _hubConnection;
    private bool showRepositoriesModal;
    private bool isSavingRepositories;
    private bool isPersisting;
    private bool hasConnectors;
    private string? repositoriesModalErrorMessage;
    private List<GitHubRepositoryEntry>? repositoriesModalRepositories;
    private HashSet<int> selectedRepositoryIds = new();
    private int? fetchedRepositoryCount;
    private CancellationTokenSource? _fetchRepositoriesCts;
    private bool showSwitchBranchModal = false;
    private int switchBranchRepositoryId;
    private string? switchBranchRepositoryName;
    private string? switchBranchCurrentBranch;
    private string? switchBranchRepositoryUrl;

    protected override async Task OnInitializedAsync()
    {
        await LoadWorkspaceAsync();
        ApplySyncStateFromWorkspace();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && workspace != null && errorMessage == null)
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/hubs/workspace-sync"))
                .WithAutomaticReconnect()
                .Build();
            _hubConnection.On<int>("WorkspaceSynced", async (workspaceId) =>
            {
                if (workspaceId == WorkspaceId)
                    await InvokeAsync(RefreshFromSync);
            });
            await _hubConnection.StartAsync();
        }
    }

    private void ApplySyncStateFromWorkspace()
    {
        if (workspace == null || workspaceRepositories.Count == 0)
        {
            return;
        }
        repoSyncStatus = workspaceRepositories
            .Where(wr => wr.Repository != null)
            .ToDictionary(wr => wr.RepositoryId, wr => wr.SyncStatus);
        isOutOfSync = repoSyncStatus.Values.Any(s => s != RepoSyncStatus.InSync);
        StateHasChanged();
    }

    public void Dispose()
    {
        _ = _hubConnection?.StopAsync();
        _hubConnection?.DisposeAsync();
        _syncCts?.Cancel();
        _syncCts?.Dispose();
        _updateCts?.Cancel();
        _updateCts?.Dispose();
        _pullPushCts?.Cancel();
        _pullPushCts?.Dispose();
        _fetchRepositoriesCts?.Cancel();
        _fetchRepositoriesCts?.Dispose();
    }

    /// <summary>Called when WorkspaceSynced is received (or after Update): reload from a fresh scope so the grid gets current DB values (no stale DbContext).</summary>
    private async Task RefreshFromSync()
    {
        if (isSyncing || isUpdating)
            return;
        await ReloadWorkspaceDataFromFreshScopeAsync();
        ApplySyncStateFromWorkspace();
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadWorkspaceAsync()
    {
        try
        {
            isLoading = true;
            errorMessage = null;
            await ReloadWorkspaceDataAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading workspace {WorkspaceId}", WorkspaceId);
            errorMessage = "Failed to load workspace. Please try again later.";
            workspaceRepositories = new List<WorkspaceRepositoryLink>();
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task ReloadWorkspaceDataAsync()
    {
        workspace = await WorkspaceRepository.GetByIdAsync(WorkspaceId);
        if (workspace == null)
        {
            errorMessage = "Workspace not found.";
            workspaceRepositories = new List<WorkspaceRepositoryLink>();
            return;
        }

        workspaceRepositories = workspace.Repositories
            .OrderByDescending(wr => wr.Sequence ?? int.MinValue)
            .ThenByDescending(wr => wr.Dependencies ?? int.MinValue)
            .ToList();
    }

    /// <summary>Loads workspace using a new scope (fresh DbContext) so we get current DB values and avoid EF cache. Used by RefreshFromSync so the grid shows updated UnmatchedDeps after notify or Update.</summary>
    private async Task ReloadWorkspaceDataFromFreshScopeAsync()
    {
        await using var scope = ServiceScopeFactory.CreateAsyncScope();
        var repo = scope.ServiceProvider.GetRequiredService<WorkspaceRepository>();
        var w = await repo.GetByIdAsync(WorkspaceId);
        if (w == null)
        {
            errorMessage = "Workspace not found.";
            workspaceRepositories = new List<WorkspaceRepositoryLink>();
            return;
        }
        workspace = w;
        workspaceRepositories = workspace.Repositories
            .OrderByDescending(wr => wr.Sequence ?? int.MinValue)
            .ThenByDescending(wr => wr.Dependencies ?? int.MinValue)
            .ToList();
    }

    private RenderFragment GetCommitsBadge(int repositoryId, int? outgoing, int? incoming) => builder =>
    {
        var x = outgoing ?? 0;
        var y = incoming ?? 0;
        if (!outgoing.HasValue && !incoming.HasValue)
        {
            builder.AddContent(0, "-");
            return;
        }
        var text = $"↑{x} ↓{y}";
        string bgColor;
        bool hasCommits = (y > 0) || (x > 0);
        if (y > 0)
            bgColor = "#dc3545";   // red: need to pull
        else if (x > 0)
            bgColor = "#fd7e14";   // orange: need to push
        else
            bgColor = "#198754";   // green: in sync (0,0)
        
        builder.OpenElement(0, "span");
        builder.AddAttribute(1, "class", "badge");
        builder.AddAttribute(2, "style", $"background-color: {bgColor}; color: #fff;{(hasCommits ? " cursor: pointer;" : "")}");
        if (hasCommits)
        {
            builder.AddAttribute(3, "onclick", EventCallback.Factory.Create<Microsoft.AspNetCore.Components.Web.MouseEventArgs>(this, () => PullPushAsync(repositoryId)));
            builder.AddAttribute(4, "title", "Click to pull/push");
        }
        builder.AddContent(5, text);
        builder.CloseElement();
    };

    private RenderFragment GetRepoSyncBadge(int repositoryId) => builder =>
    {
        if (repoSyncStatus.TryGetValue(repositoryId, out var status))
        {
            var (text, bgColor) = status switch
            {
                RepoSyncStatus.InSync => ("in sync", "#198754"),
                RepoSyncStatus.NeedsSync => ("sync", "#dc3545"),
                RepoSyncStatus.NotCloned => ("not cloned", "#6c757d"),
                RepoSyncStatus.VersionMismatch => ("version", "#dc3545"),
                RepoSyncStatus.Error => ("error", "#dc3545"),
                _ => ("sync", "#6c757d")
            };
            builder.OpenElement(0, "span");
            builder.AddAttribute(1, "class", "badge");
            builder.AddAttribute(2, "style", $"background-color: {bgColor}; color: #fff;");
            builder.AddContent(3, text);
            builder.CloseElement();
        }
    };

    private void AbortSyncAsync()
    {
        _syncCts?.Cancel();
    }

    private void AbortUpdateAsync()
    {
        _updateCts?.Cancel();
    }

    private void AbortPullPushAsync()
    {
        _pullPushCts?.Cancel();
    }

    /// <summary>User-triggered: refresh project/dependency data and write .csproj files to match referenced versions. Runs in a fresh scope so the DB context sees current state (e.g. UnmatchedDeps from notify) and GetSyncDependenciesPayloadAsync returns correct payload.</summary>
    private async Task UpdateDependenciesAsync()
    {
        if (workspace == null || workspaceRepositories.Count == 0 || isUpdating || isSyncing)
            return;

        _updateCts?.Cancel();
        _updateCts?.Dispose();
        _updateCts = new CancellationTokenSource();

        isUpdating = true;
        updateProgressMessage = "Refreshing projects...";
        errorMessage = null;
        try
        {
            StateHasChanged();
            await Task.Yield();

            await using (var scope = ServiceScopeFactory.CreateAsyncScope())
            {
                var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
                await workspaceGitService.RefreshWorkspaceProjectsAsync(
                    WorkspaceId,
                    onProgress: (completed, total, _) =>
                    {
                        updateProgressMessage = $"Refreshing projects {completed} of {total}";
                        InvokeAsync(StateHasChanged);
                    },
                    cancellationToken: _updateCts.Token);

                updateProgressMessage = "Syncing dependencies...";
                await InvokeAsync(StateHasChanged);
                await workspaceGitService.SyncDependenciesAsync(
                    WorkspaceId,
                    onProgress: (completed, total, _) =>
                    {
                        updateProgressMessage = $"Synced dependencies {completed} of {total}";
                        InvokeAsync(StateHasChanged);
                    },
                    cancellationToken: _updateCts.Token);

                await workspaceGitService.RecomputeAndBroadcastWorkspaceSyncedAsync(WorkspaceId, _updateCts.Token);
            }

            isUpdating = false;
            await InvokeAsync(StateHasChanged);
            await RefreshFromSync();
        }
        catch (OperationCanceledException)
        {
            isUpdating = false;
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating dependencies for workspace {WorkspaceId}", WorkspaceId);
            errorMessage = "Update failed. The GrayMoon Agent may be offline. Start the Agent and try again.";
        }
        finally
        {
            isUpdating = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ShowRepositoriesModalAsync()
    {
        if (workspace == null)
        {
            return;
        }
        repositoriesModalErrorMessage = null;
        selectedRepositoryIds = workspace.Repositories
            .Select(link => link.RepositoryId)
            .ToHashSet();
        await EnsureRepositoriesForModalAsync();
        showRepositoriesModal = true;
    }

    private async Task EnsureRepositoriesForModalAsync()
    {
        var connectors = await ConnectorRepository.GetAllAsync();
        hasConnectors = connectors.Count > 0;
        if (repositoriesModalRepositories == null && hasConnectors)
        {
            repositoriesModalRepositories = await RepositoryService.GetPersistedRepositoriesAsync();
        }
    }

    private void CloseRepositoriesModal()
    {
        showRepositoriesModal = false;
        repositoriesModalErrorMessage = null;
    }

    private async Task SaveRepositoriesAsync()
    {
        if (workspace == null || isSavingRepositories)
        {
            return;
        }
        if (selectedRepositoryIds.Count == 0)
        {
            repositoriesModalErrorMessage = "Select at least one repository.";
            return;
        }
        isSavingRepositories = true;
        repositoriesModalErrorMessage = null;
        await InvokeAsync(StateHasChanged);
        try
        {
            await WorkspaceRepository.UpdateAsync(WorkspaceId, workspace.Name, selectedRepositoryIds);
            CloseRepositoriesModal();
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving repositories for workspace {WorkspaceId}", WorkspaceId);
            repositoriesModalErrorMessage = ex.Message;
        }
        finally
        {
            isSavingRepositories = false;
        }
    }

    private void AbortFetchRepositories()
    {
        _fetchRepositoriesCts?.Cancel();
    }

    private async Task FetchRepositoriesAsync()
    {
        if (!hasConnectors || isPersisting)
        {
            return;
        }
        _fetchRepositoriesCts?.Cancel();
        _fetchRepositoriesCts = new CancellationTokenSource();
        try
        {
            isPersisting = true;
            fetchedRepositoryCount = null;
            repositoriesModalErrorMessage = null;
            await InvokeAsync(StateHasChanged);
            var progress = new Progress<int>(count =>
            {
                fetchedRepositoryCount = count;
                _ = InvokeAsync(StateHasChanged);
            });
            var result = await RepositoryService.RefreshRepositoriesAsync(progress, _fetchRepositoriesCts.Token);
            repositoriesModalRepositories = result.Repositories.ToList();
        }
        catch (OperationCanceledException)
        {
            repositoriesModalRepositories = await RepositoryService.GetPersistedRepositoriesAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error fetching repositories");
            repositoriesModalErrorMessage = "Failed to fetch repositories. Please try again later.";
            repositoriesModalRepositories = new List<GitHubRepositoryEntry>();
        }
        finally
        {
            isPersisting = false;
        }
    }

    /// <summary>Sync repos only (git, version, branch, commit counts). Does not read or write .csproj; dependency mismatches are resolved only by Update. Runs in a fresh scope so DbContext is not stale and PersistVersionsAsync → dependency recompute sees current state.</summary>
    private async Task SyncAsync()
    {
        if (workspace == null || workspaceRepositories.Count == 0 || isSyncing)
        {
            return;
        }

        _syncCts?.Cancel();
        _syncCts = new CancellationTokenSource();

        isSyncing = true;
        syncProgressMessage = "Synchronizing...";
        errorMessage = null;
        try
        {
            StateHasChanged();
            await Task.Yield();

            await using (var scope = ServiceScopeFactory.CreateAsyncScope())
            {
                var workspaceGitService = scope.ServiceProvider.GetRequiredService<WorkspaceGitService>();
                var results = await workspaceGitService.SyncAsync(
                    WorkspaceId,
                    onProgress: (completed, total, repoId, info) =>
                    {
                        syncProgressMessage = $"Synchronized {completed} of {total}";
                        repoSyncStatus[repoId] = (info.Version == "-" && info.Branch == "-")
                            ? RepoSyncStatus.Error
                            : RepoSyncStatus.InSync;
                        var wr = workspaceRepositories.FirstOrDefault(w => w.RepositoryId == repoId);
                        if (wr != null)
                        {
                            wr.GitVersion = info.Version == "-" ? null : info.Version;
                            wr.BranchName = info.Branch == "-" ? null : info.Branch;
                            wr.Projects = info.Projects;
                            wr.OutgoingCommits = info.OutgoingCommits;
                            wr.IncomingCommits = info.IncomingCommits;
                        }
                        InvokeAsync(StateHasChanged);
                    },
                    cancellationToken: _syncCts.Token);
                repoGitInfos = results;
            }
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
            isOutOfSync = repoSyncStatus.Values.Any(v => v != RepoSyncStatus.InSync);
            
            // Clear errors on sync (new errors will be shown if they occur)
            repositoryErrors.Clear();
        }
        catch (OperationCanceledException)
        {
            // Sync was cancelled - reload workspace to restore pre-sync data (onProgress may have partially updated in-memory state)
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error syncing workspace {WorkspaceId}", WorkspaceId);
            errorMessage = "Sync failed. The GrayMoon Agent may be offline. Start the Agent and try again.";
        }
        finally
        {
            isSyncing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task PullPushAsync(int repositoryId)
    {
        if (workspace == null || isPullPushing || isSyncing || isUpdating)
            return;

        _pullPushCts?.Cancel();
        _pullPushCts?.Dispose();
        _pullPushCts = new CancellationTokenSource();

        isPullPushing = true;
        pullPushProgressMessage = "Synchronizing commits...";
        errorMessage = null;
        try
        {
            StateHasChanged();
            await Task.Yield();

            var httpClient = HttpClientFactory.CreateClient();
            var request = new
            {
                repositoryId,
                workspaceId = WorkspaceId
            };
            var json = System.Text.Json.JsonSerializer.Serialize(request);
            var content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");
            
            var baseUrl = NavigationManager.BaseUri.TrimEnd('/');
            var response = await httpClient.PostAsync($"{baseUrl}/api/pullpush", content, _pullPushCts.Token);
            
            if (response.IsSuccessStatusCode)
            {
                var responseContent = await response.Content.ReadAsStringAsync(_pullPushCts.Token);
                var result = System.Text.Json.JsonSerializer.Deserialize<System.Text.Json.JsonElement>(responseContent);
                
                // Check for error message in response
                if (result.TryGetProperty("errorMessage", out var errorMsg) && errorMsg.ValueKind != System.Text.Json.JsonValueKind.Null)
                {
                    var errorText = errorMsg.GetString();
                    if (!string.IsNullOrWhiteSpace(errorText))
                    {
                        repositoryErrors[repositoryId] = errorText;
                        pullPushProgressMessage = "Pull/Push completed with errors.";
                        await Task.Delay(2000, _pullPushCts.Token);
                    }
                    else
                    {
                        // Clear error if operation succeeded
                        repositoryErrors.Remove(repositoryId);
                        pullPushProgressMessage = "Pull/Push completed successfully.";
                        await Task.Delay(1000, _pullPushCts.Token);
                    }
                }
                else if (result.TryGetProperty("mergeConflict", out var mergeConflict) && mergeConflict.GetBoolean())
                {
                    pullPushProgressMessage = "Merge conflict detected. Merge aborted.";
                    await Task.Delay(2000, _pullPushCts.Token);
                }
                else
                {
                    // Clear error if operation succeeded
                    repositoryErrors.Remove(repositoryId);
                    pullPushProgressMessage = "Pull/Push completed successfully.";
                    await Task.Delay(1000, _pullPushCts.Token);
                }
            }
            else
            {
                var errorText = await response.Content.ReadAsStringAsync(_pullPushCts.Token);
                repositoryErrors[repositoryId] = $"Pull/Push failed: {response.StatusCode}";
                errorMessage = $"Pull/Push failed: {response.StatusCode}";
                Logger.LogError("PullPush failed: {StatusCode}, {Error}", response.StatusCode, errorText);
            }

            // Refresh workspace data to show updated commit counts
            await RefreshFromSync();
        }
        catch (OperationCanceledException)
        {
            // Operation was cancelled
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error pulling/pushing repository {RepositoryId}", repositoryId);
            var errorMsg = "Pull/Push failed. The GrayMoon Agent may be offline. Start the Agent and try again.";
            repositoryErrors[repositoryId] = errorMsg;
            errorMessage = errorMsg;
        }
        finally
        {
            isPullPushing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void ShowSwitchBranchModal(int repositoryId, string? currentBranch, string? cloneUrl)
    {
        var wr = workspaceRepositories.FirstOrDefault(wr => wr.RepositoryId == repositoryId);
        var repo = wr?.Repository;
        
        if (repo == null)
            return;

        switchBranchRepositoryId = repositoryId;
        switchBranchRepositoryName = repo.RepositoryName;
        switchBranchCurrentBranch = currentBranch;
        // Use cloneUrl if provided, otherwise try to get from repo
        switchBranchRepositoryUrl = cloneUrl ?? repo.CloneUrl;
        showSwitchBranchModal = true;
        StateHasChanged();
    }

    private void CloseSwitchBranchModal()
    {
        showSwitchBranchModal = false;
        switchBranchRepositoryId = 0;
        switchBranchRepositoryName = null;
        switchBranchCurrentBranch = null;
        switchBranchRepositoryUrl = null;
    }

    private async Task OnBranchChangedAsync()
    {
        // Refresh workspace data to show updated branch
        await RefreshFromSync();
    }

    private async Task CheckoutBranchAsync((int RepositoryId, string BranchName) request)
    {
        var (repositoryId, branchName) = request;
        if (workspace == null || isCheckingOut || isSyncing || isUpdating || isPullPushing)
            return;

        _checkoutCts?.Cancel();
        _checkoutCts?.Dispose();
        _checkoutCts = new CancellationTokenSource();

        isCheckingOut = true;
        
        // Get repository name for display
        var repo = workspaceRepositories.FirstOrDefault(wr => wr.RepositoryId == repositoryId)?.Repository;
        var repoName = repo?.RepositoryName ?? "repository";
        checkoutProgressMessage = $"Checking out {branchName} for {repoName}...";
        
        errorMessage = null;
        try
        {
            StateHasChanged();
            await Task.Yield();

            var httpClient = HttpClientFactory.CreateClient();
            var apiRequest = new
            {
                repositoryId,
                workspaceId = WorkspaceId,
                branchName
            };
            var json = System.Text.Json.JsonSerializer.Serialize(apiRequest);
            var content = new System.Net.Http.StringContent(json, System.Text.Encoding.UTF8, "application/json");
            
            var baseUrl = NavigationManager.BaseUri.TrimEnd('/');
            var response = await httpClient.PostAsync($"{baseUrl}/api/branches/checkout", content, _checkoutCts.Token);
            var responseContent = await response.Content.ReadAsStringAsync(_checkoutCts.Token);

            if (response.IsSuccessStatusCode)
            {
                var success = true;
                var errorMsg = (string?)null;
                try
                {
                    var doc = System.Text.Json.JsonDocument.Parse(responseContent);
                    var root = doc.RootElement;
                    if (root.TryGetProperty("success", out var successProp))
                        success = successProp.GetBoolean();
                    if (root.TryGetProperty("errorMessage", out var errProp) && errProp.ValueKind != System.Text.Json.JsonValueKind.Null)
                        errorMsg = errProp.GetString();
                }
                catch { /* use defaults */ }

                if (success)
                {
                    // Refresh workspace data to show updated branch
                    await RefreshFromSync();
                }
                else
                {
                    // Store error for this repository
                    repositoryErrors[repositoryId] = errorMsg ?? "Failed to checkout branch.";
                }
            }
            else
            {
                var errorText = await response.Content.ReadAsStringAsync(_checkoutCts.Token);
                repositoryErrors[repositoryId] = $"Failed to checkout branch: {response.StatusCode}";
                Logger.LogError("Checkout failed: {StatusCode}, {Error}", response.StatusCode, errorText);
            }
        }
        catch (OperationCanceledException)
        {
            // Operation was cancelled
            await ReloadWorkspaceDataAsync();
            ApplySyncStateFromWorkspace();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error checking out branch for repository {RepositoryId}", repositoryId);
            repositoryErrors[repositoryId] = "Failed to checkout branch. The GrayMoon Agent may be offline. Start the Agent and try again.";
        }
        finally
        {
            isCheckingOut = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void AbortCheckoutAsync()
    {
        _checkoutCts?.Cancel();
    }

    private void DismissRepositoryError(int repositoryId)
    {
        repositoryErrors.Remove(repositoryId);
        StateHasChanged();
    }

    private string? GetRepositoryUrl(Repository repo)
    {
        if (string.IsNullOrEmpty(repo.CloneUrl))
            return null;

        // Convert git clone URL to GitHub web URL
        // Examples:
        // https://github.com/org/repo.git -> https://github.com/org/repo
        // git@github.com:org/repo.git -> https://github.com/org/repo
        // https://github.com/org/repo -> https://github.com/org/repo (already correct)
        
        var url = repo.CloneUrl.Trim();
        
        // Handle SSH format: git@github.com:org/repo.git
        if (url.StartsWith("git@github.com:", StringComparison.OrdinalIgnoreCase))
        {
            url = url.Replace("git@github.com:", "https://github.com/", StringComparison.OrdinalIgnoreCase);
        }
        // Handle HTTPS format: https://github.com/org/repo.git
        else if (url.StartsWith("https://github.com/", StringComparison.OrdinalIgnoreCase) || 
                 url.StartsWith("http://github.com/", StringComparison.OrdinalIgnoreCase))
        {
            // Already HTTPS/HTTP, just need to remove .git if present
        }
        else
        {
            // Unknown format, return null
            return null;
        }
        
        // Remove .git suffix if present
        if (url.EndsWith(".git", StringComparison.OrdinalIgnoreCase))
        {
            url = url.Substring(0, url.Length - 4);
        }
        
        return url;
    }
}
