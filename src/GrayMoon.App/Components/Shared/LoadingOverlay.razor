@inject IJSRuntime JS
@inject MatrixOverlayPreferenceService MatrixPreference
@implements IAsyncDisposable
@implements IDisposable

<div class="loading-overlay @(IsVisible ? "show" : "") @(MatrixPreference.UseMatrixEffect ? "loading-overlay--matrix" : "loading-overlay--simple")" aria-hidden="@(!IsVisible)">
    @if (MatrixPreference.UseMatrixEffect)
    {
        <canvas id="@_canvasId" class="matrix-canvas"></canvas>
        <div class="loading-overlay__veil"></div>
    }
    <div class="loading-overlay-content">
        <div class="spinner-border" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        @if (!string.IsNullOrEmpty(Message))
        {
            <p class="loading-overlay-message">@Message</p>
        }
        @if (OnAbort.HasDelegate)
        {
            <button type="button" class="btn btn-outline-light btn-sm" @onclick="AbortClicked">Abort</button>
        }
    </div>
</div>

@code {
    [Parameter] public bool IsVisible { get; set; }
    [Parameter] public string? Message { get; set; }
    [Parameter] public EventCallback OnAbort { get; set; }

    /// <summary>Dim strength 0..100 (matrix mode only).</summary>
    [Parameter] public int DimOpacityPercent { get; set; } = 45;

    /// <summary>Matrix rain: character size in px.</summary>
    [Parameter] public int FontSize { get; set; } = 16;
    /// <summary>Matrix rain: frame interval in ms (~20 FPS = 50).</summary>
    [Parameter] public int FrameIntervalMs { get; set; } = 50;
    /// <summary>Matrix rain: trail length (e.g. 0.08).</summary>
    [Parameter] public double FadeAlpha { get; set; } = 0.08;
    /// <summary>Matrix rain: character opacity (e.g. 0.65).</summary>
    [Parameter] public double CharacterOpacity { get; set; } = 0.65;
    /// <summary>Matrix rain: fall speed (0.1â€“2, default 0.6 = slower).</summary>
    [Parameter] public double DropSpeed { get; set; } = 0.6;

    private readonly string _canvasId = "matrixOverlay_" + Guid.NewGuid().ToString("N");
    private bool _wasVisible;
    private bool _wasMatrixEffect;

    protected override void OnInitialized()
    {
        MatrixPreference.UseMatrixEffectChanged += OnMatrixPreferenceChanged;
    }

    private void OnMatrixPreferenceChanged(object? sender, EventArgs e)
    {
        _ = InvokeAsync(StateHasChanged);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        var useMatrix = MatrixPreference.UseMatrixEffect;

        if (useMatrix)
        {
            await JS.InvokeVoidAsync("matrixOverlay.setDim", _canvasId, DimOpacityPercent / 100.0);
        }

        if (useMatrix && IsVisible)
        {
            if (!_wasVisible || !_wasMatrixEffect)
            {
                await JS.InvokeVoidAsync("matrixOverlay.start", _canvasId, new
                {
                    fontSize = FontSize,
                    frameIntervalMs = FrameIntervalMs,
                    fadeAlpha = FadeAlpha,
                    characterOpacity = CharacterOpacity,
                    dropSpeed = DropSpeed
                });
            }
        }
        else if (_wasMatrixEffect && (!useMatrix || !IsVisible))
        {
            await JS.InvokeVoidAsync("matrixOverlay.stop", _canvasId);
        }

        _wasVisible = IsVisible;
        _wasMatrixEffect = useMatrix;
    }

    private async Task AbortClicked() => await OnAbort.InvokeAsync();

    public void Dispose()
    {
        MatrixPreference.UseMatrixEffectChanged -= OnMatrixPreferenceChanged;
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (MatrixPreference.UseMatrixEffect)
            {
                await JS.InvokeVoidAsync("matrixOverlay.stop", _canvasId);
            }
        }
        catch (Exception)
        {
            // JS interop may be unavailable (e.g. circuit disconnected); ignore
        }
    }
}
